decode_digits
Questa funzione, sapendo che digits e bases sono della stessa lunghezza, crea una variabile out = 0 ed esegue un for per iterare lungo tutta la lunghezza di digits (che sarà uguale a quella di bases e dunque puntando con lo stesso indice alle due liste avrò sempre un risultato coerente). A questo punto ad out viene aggiunto ogni volta il valore corrispondente di ogni singola digits (selezionata attraverso l'indice i) rispetto alla singola base (selezionata attraverso l'indice i). Alla fine restituisce la variabile out che contiene la somma di tutti i valori calcolati precedentemente.

generate_digits
In questa funzione ho inizializzato due variabili: out (che conterrà tutte le combinazioni di cifre compatibili con le basi date) e end (tanti zeri quanto è lunga bases). La mia idea è quella di implementare un vero e proprio addizionatore in modo tale da incrementare end fino a renderla uguale a bases.
Innanzitutto eseguo un while che verrà eseguito fin tanto che il primo indice di end sarà minore del primo indice di bases. Quindi ad out appendo end stesso e incremento l'ultima cifra di out di uno. A questo punto creo un indice i che itera attraverso un while in direzione opposta di end fino alla seconda cifra della lista e verifico se per ogni i bases[i] è uguale a end[i], e, in caso affermativo, rendere end[i] uguale a zero e incrementando la cifra precedente end[i-1] (ovvero la cifra precendente di end[i] ma mantenendo a mente che sto iterando dalla fine). Questo in modo tale da implementare un vero e proprio addizionatore che tiene conto del carry.
Infatti se per esempio si arriva ad un punto del loop in cui si ha end = [0,2,2] e bases = [4,3,2], attraverso l'if dentro il while che itera al contrario il programma noterà che l'ultima cifra di bases è uguale all'ultima cifra di end quindi azzererà quest'ultima e incrementerà di 1 la precedente rendendo end = [0,3,0] a questo punto nuovamente l'if noterà che la penulitima cifra di end è uguale alla penultima cifra di bases, la porterà uguale a zero e incrementerà la precedente di 1 rendendo end = [1,0,0] che farà quindi iniziare un nuovo ciclo del while che ricomincerà il processo.

find_doubles
Questa funzione prima di tutto cacolerà la lista digits applicando su bases la funzione generate_digits. Quindi ho inizializzato un dizionario e creato una lista con tutti i risultati di decode_digits attraverso una lista comprehension. A questo punto attraverso un for ho fatto in modo di aggiungere come key il valore di ogni singolo numero presente in full_res e come value la ripetizione di quest'ultimo. Infine ho creato un set tramite set comprehension a cui vengono aggiunte tutte quelle key la cui value (ripetizione) è maggiore di 1.