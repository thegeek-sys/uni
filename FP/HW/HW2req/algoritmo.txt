decode_digits
Questa funzione, sapendo che digits e bases sono della stessa lunghezza, crea una variabile out = 0 ed esegue un for per iterare lungo tutta la lunghezza di digits (che sarà uguale a quella di bases e dunque puntando con lo stesso indice alle due liste avrò sempre un risultato coerente). A questo punto ad out viene aggiunto ogni volta il valore corrispondente di ogni singola digits (selezionata attraverso l'indice i) rispetto alla singola base (selezionata attraverso l'indice i). La funzione alla fine restituisce la variabile out che contiene la somma di tutti i valori calcolati precedentemente.

generate_digits
In questa funzione ho inizializzato due variabili: out (che alla fine conterrà tutte le combinazioni di cifre compatibili con le basi date) e end (tanti zeri quanto è lunga bases). La mia idea è stata quella di implementare un vero e proprio addizionatore (usa sorta di ripple carry adder) in modo tale da incrementare end fino a renderla uguale a bases.
Innanzitutto eseguo un while che verrà eseguito fin tanto che il primo indice di end sarà minore del primo indice di bases. Quindi ad out appendo end stesso e ne incremento l'ultima cifra di uno. A questo punto creo un indice i uguale alla lunghezza di end meno uno (per evitare IndexError) che verrà usato all'interno del while della riga successiva per iterare tutto end in direzione opposta (dalla fine all'inizio). Uso il while per gestire il riporto; questo infatti controllerà sia che il valore dell'indice i di end è uguale al valore dell'indice i di bases (per gestire un eventuale riporto) sia che i sia maggiore di 0 (infatti all'interno del while gli sottrarrò 1 ad ogni iterazione in modo tale fa eseguire una sorta di for i in range(len(bases)-1,0,-1) e dunque per iterare lungo end al contrario). Quindi nel caso in cui ci sia un riporto da aggiungere (quando end[i] sarà uguale a bases[i]) verrà azzerato end[i] e verrà aggiunto 1 a end[i-1]. Iterando al contrario avrò la possibilità di gestire eventuali ulteriori riporti che verranno generati.
Infatti se per esempio si arriva ad un punto del loop in cui si ha end = [0,2,2] e bases = [4,3,2], attraverso il while, il programma noterà che l'ultima cifra di bases è uguale all'ultima cifra di end quindi azzererà quest'ultima e incrementerà di 1 la precedente rendendo end = [0,3,0]. A questo punto nuovamente il while noterà che la penulitima cifra di end è uguale alla penultima cifra di bases, la imposterà a zero e incrementerà la precedente di 1 rendendo end = [1,0,0], operazione che renderà i uguale a 0 (e non più maggiore) per quindi iniziare un nuovo ciclo del while precedente.

find_doubles
Questa funzione prima di tutto creerà la lista che ho chiamato digits applicando su bases la funzione generate_digits. Quindi ho inizializzato un dizionario e creato una lista con tutti i risultati di decode_digits attraverso una list comprehension. A questo punto attraverso un for ho fatto in modo di aggiungere al dizionario buff come key il valore di ogni singolo numero presente in full_res e come value quante volte quest'ultimo si ripete, sfruttando la funzione get dei dizionari. Infine ho creato un set (doubles nel codice) tramite set comprehension a cui vengono aggiunte tutte quelle key (numeri calcolati da decode_digits) la cui value (ripetizione) è maggiore di 1. Quindi viene eseguito un return di doubles.