[
  {
    "answers": [
      "È sempre necessario identificare un file di un file system fornendone il path assoluto",
      "È sempre necessario identificare un file di un file system fornendone il path relativo alla directory corrente",
      "È sempre possibile dare lo stesso nome a file diversi",
      "Nessuna delle altre opzioni è vera"
    ],
    "correct": "d",
    "question": "1) Quale delle seguenti affermazioni sulle directory di un file system è vera?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "La disabilitazione delle interruzioni impedisce la creazione di nuove interruzioni",
      "L'abuso della disabilitazione delle interruzioni fa diminuire la multiprogrammazione, a parità di numero di processi",
      "Se un processo può disabilitare le interruzioni tramite un'istruzione macchina dedicata, allora può far diminuire l'uso del processore",
      "La disabilitazione delle interruzioni non funziona su sistemi con più processori o più core"
    ],
    "correct": "a",
    "question": "2) Quale delle seguenti affermazioni sulla concorrenza tra processi o thread è falsa?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Lo scheduler ha, tra i suoi obiettivi, quello di minimizzare il numero di processi che rispettano la propria deadline",
      "Lo scheduler ha, tra i suoi obiettivi, quello di minimizzare il volume di lavoro nel tempo",
      "Lo scheduler ha, tra i suoi obiettivi, quello di massimizzare il tempo di risposta",
      "Lo scheduler ha, tra i suoi obiettivi, quello di minimizzare il tempo di inattività del processore"
    ],
    "correct": "d",
    "question": "3) Assumendo un sistema monoprocessore, quale delle seguenti affermazioni è vera? ",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Se un processo è Zombie, allora è terminato ma il suo process control block è ancora in memoria",
      "Asleep in Memory coincide con Blocked",
      "Ha anche uno stato Zombie: serve per tutti i processi che sono terminati",
      "Ha 9 stati (10 con Exit)"
    ],
    "correct": "c",
    "question": "4) Quale delle seguenti affermazioni sul modello dei processi in UNIX SVR4 System V Release 4 è falsa?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Quando un indirizzo non viene trovato nel translation lookaside buffer, è necessario consultare la normale tabella delle pagine",
      "Il translation lookaside buffer è una particolare cache, ma non è completamente trasparente al sistema operativo",
      "Il translation lookaside buffer permette di accedere direttamente al contenuto degli indirizzi di memoria virtuali usati più di recente",
      "In assenza di translation lookaside buffer, l'accesso ad un indirizzo virtuale può richiedere almeno 2 accessi in memoria"
    ],
    "correct": "c",
    "question": "5) Quale delle seguenti affermazioni sulla memoria virtuale con paginazione è falsa? ",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Per \"disponibilità\" dell'hardware si intende la garanzia che le workstation restino sempre fisse in un posto",
      "Per \"confidenzialità\" dei dati si intende la garanzia che essi non possano essere generati automaticamente",
      "Nessuna delle altre opzioni è vera",
      "Per \"integrità\" dei dati si intende la garanzia che essi non vengano mai modificati"
    ],
    "correct": "c",
    "question": "6) Quale delle seguenti affermazioni sugli obiettivi di sicurezza di un sistema operativo è vera?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Nessuna delle altre opzioni è corretta",
      "Avviene direttamente su disco, altrimenti si rischia il deadlock per interferenze con il DMA",
      "Nel caso ci siano più buffer, vanno gestiti come nel problema dei lettori/scrittori",
      "Può consistere nel completare un'istruzione di output I dopo che alcune istruzioni successive ad I siano state eseguite"
    ],
    "correct": "d",
    "question": "7) Quale delle seguenti affermazioni sul buffering dell'I/O è vera? ",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Nessuna delle altre opzioni è vera",
      "Può essere usato per visualizzare le possibilità di deadlock, ma solo se i processi richiedono al massimo 2 risorse",
      "Può essere usato per determinare quando uno dei due processi va in esecuzione a discapito dell'altro",
      "Può essere usato per determinare quando uno dei due processi sperimenta un page fault"
    ],
    "correct": "a",
    "question": "8) Quale delle seguenti affermazioni, riguardanti il joint progress diagram di 2 processi, è vera?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Nessuna delle altre opzioni è corretta",
      "Andando dall'alto in basso, cresce il costo",
      "Andando dall'alto in basso, diminuisce la capacità",
      "Andando dall'alto in basso, diminuisce la frequenza di accesso alla memoria da parte del processore"
    ],
    "correct": "d",
    "question": "9) Quale delle seguenti affermazioni sulla gerarchia della memoria è vera?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Il puntatore alla tabella delle pagine",
      "L’identificatore del thread",
      "Lo stato o modalità",
      "L’identificatore del processo"
    ],
    "correct": "b",
    "question": "10) Quale dei seguenti elementi non fa parte del process control block?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Nessuna delle altre opzioni è vera",
      "Il quanto di tempo ottimale per lo scheduler round-robin è maggiore del tipico tempo di completa esecuzione di un processo interattivo",
      "Lo scheduler First Come First Served favorisce i processi I/O-bound",
      "Anche assumendo che tutti i processi prima o poi terminino, lo scheduler First Come First Served soffre di starvation"
    ],
    "correct": "a",
    "question": "11) Assumendo un sistema monoprocessore, quale delle seguenti affermazioni sugli algoritmi di scheduling è vera?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Diversi segmenti possono avere diverse lunghezze",
      "Differentemente dalla paginazione, il programmatore assembler di un processo non interagisce esplicitamente con la gestione dei segmenti",
      "Per accedere ad un indirizzo contenuto in un segmento di un processo, tale segmento dovrà essere posizionato in memoria principale",
      "Un indirizzo di memoria principale va visto come un numero di segmento più uno spiazzamento all'interno di tale segmento"
    ],
    "correct": "b",
    "question": "14) Quale delle seguenti affermazioni sulla segmentazione della memoria è falsa? ",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Richiede in input, per ogni processo p e per ogni risorsa r, il numero massimo di istanze di r che p chiederà nel corso della sua esecuzione",
      "Se al passo 3 viene trovato un processo non marcato che soddisfi la condizione Qik ≤ wik, allora c'è un deadlock",
      "I processi marcati sono quelli che non sono coinvolti in un deadlock",
      "Nessuna delle altre opzioni è vera"
    ],
    "correct": "c",
    "question": "15) Quale delle seguenti affermazioni sull'algoritmo per il rilevamento del deadlock visto a lezione è vera?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Viene chiamato in causa esclusivamente quando viene creato un nuovo processo",
      "Avendo le necessarie informazioni, una tipica strategia è mantenere una giusta proporzione, stabilita a priori, tra processi I/O-bound e CPU-bound",
      "Avendo le necessarie informazioni, una tipica strategia è ammettere in memoria principale i processi che richiedono dispositivi di I/O diversi da quelli richiesti dai processi già attivi",
      "Decide quali processi, tra quelli appena creati, possono essere ammessi in memoria principale per l'esecuzione"
    ],
    "correct": "a",
    "question": "16) Assumendo un sistema monoprocessore, quale delle seguenti affermazioni sul long-term scheduler è falsa? ",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Il difetto principale del prepaging è che potrebbe portare in memoria pagine cui poi non si fa riferimento",
      "Placement policy e replacement policy sono sinonimi ed indicano lo stesso insieme di metodologie",
      "Nessuna delle altre opzioni è corretta",
      "Il difetto principale del paging on demand è che causa molti page fault dopo alcuni secondi di esecuzione"
    ],
    "correct": "a",
    "question": "17) Quale delle seguenti affermazioni sulla memoria virtuale con paginazione è vera? ",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Non deve essere fatta alcuna assunzione sulla velocità di esecuzione dei processi coinvolti",
      "Se un processo fa richiesta di entrare nella sezione critica, deve poterlo fare subito",
      "Se un processo non fa richiesta di entrare nella sezione critica, deve comunque accordarsi all'esecuzione degli altri processi",
      "Si può assumere che un processo che non sia nella sezione critica prima o poi ci entri"
    ],
    "correct": "a",
    "question": "18) Quale dei seguenti requisiti deve soddisfare un meccanismo che offra la mutua esclusione?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Il principio di località afferma che poche pagine saranno sempre sufficienti per eseguire ogni processo senza thrashing",
      "Il thrashing si verifica quando l'overhead dovuto alla gestione della paginazione è molto basso",
      "Nessuna delle altre opzioni è corretta",
      "La paginazione con memoria virtuale funziona bene nonostante il principio di località"
    ],
    "correct": "c",
    "question": "19) Quale delle seguenti affermazioni sulla memoria virtuale con paginazione è vera? ",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Nessuna delle altre opzioni è vera",
      "L'implementazione delle primitive per lo scambio messaggi non è garantita atomica dal sistema operativo",
      "Se un processo chiama receive, finché il messaggio non viene ricevuto, tutti gli altri processi che proveranno a chiamare receive verranno bloccati",
      "Per garantire la mutua esclusione, occorre ricorrere al busy waiting se sia invio che ricezione sono non bloccanti"
    ],
    "correct": "c",
    "question": "20) Quale delle seguenti affermazioni sullo scambio messaggi per la gestione della concorrenza è vera? ",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "I dati possono essere ricavati dai metadati",
      "I metadati possono essere ricavati dai dati",
      "I file system, che adottano il metodo journaling, mantengono un log per le operazioni di sola scrittura da effettuare, realizzandole in seguito",
      "Un volume coincide sempre con un disco, quindi se un computer ha 2 dischi avrà 2 volumi"
    ],
    "correct": "c",
    "question": "21) Quali delle seguenti affermazioni sui file system è vera?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Nessuna delle altre opzioni è corretta",
      "Il data rate confronta le velocità di trasferimento dati tra 2 diversi dispositivi di I/O",
      "Ciascun dispositivo di I/O può essere usato solo da uno specifico tipo di applicazione",
      "Tutti i dispositivi di I/O scambiano informazioni con la CPU in blocchi, per motivi di efficienza"
    ],
    "correct": "a",
    "question": "22) Quale delle seguenti affermazioni sui dispositivi di I/O è vera?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Se viene usata la lista di blocchi liberi, c'è un overhead di spazio, contrariamente alla concatenazione di blocchi liberi",
      "Nessuna delle altre opzioni è vera",
      "Se ci sono blocchi da 1kB, e il disco contiene 1TB, l'occupazione dovuta alla lista di blocchi liberi è dell'1%",
      "Se viene usata la lista di blocchi liberi, una parte viene memorizzata su disco ed una parte in memoria principale"
    ],
    "correct": "a",
    "question": "23) Quale delle seguenti affermazioni sui metodi di gestione dello spazio libero su disco è vera?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Salvataggio del contesto del programma",
      "Aggiornamento delle strutture dati per la gestione della memoria",
      "Spostamento del process control block nella coda appropriata (ready, blocked, ready/suspend)",
      "Scelta di un altro processo da eseguire"
    ],
    "correct": "a",
    "question": "24) Quale delle seguenti azioni va effettuata sia per un process switch che per un mode switch, assumendo di essere in un SO nel quale le funzioni di sistema sono eseguite all'interno dei processi utente?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Nessuna delle altre opzioni è corretta",
      "Nell'algoritmo di sostituzione basato su frequenza a 2 segmenti della page cache, un blocco passa da un segmento ad un altro esclusivamente per scorrimento",
      "L'algoritmo di LFU della page cache ha buone performance quando un settore viene acceduto molto spesso in poco tempo, per poi non essere più usato",
      "L'algoritmo di sostituzione basato su frequenza a 2 segmenti della page cache può non avere buone performance quando un settore viene acceduto spesso, ma tra il primo accesso e quelli successivi ci sono N accessi ad altri settori, diversi tra loro, con N pari alla dimensione del segmento nuovo"
    ],
    "correct": "d",
    "question": "25) Quale delle seguenti affermazioni è vera?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "È responsabile dell'accensione del computer ",
      "Viene swappato dal disco alla memoria principale ad ogni context switch ",
      "È responsabile, tra le altre cose, della gestione dei processori",
      "Nessuna delle altre opzioni è corretta"
    ],
    "correct": "c",
    "question": "26) Quale delle seguenti affermazioni sul kernel di un sistema operativo è vera?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Nel controllo di accesso basato su ruoli, ad ogni ruolo è assegnato un utente",
      "Nessuna delle altre opzioni è vera",
      "Nel controllo di accesso basato su ruoli, prima di stabilire se un'operazione è lecita, è necessario consultare una tabella soggetti-ruoli-oggetti",
      "Nel controllo di accesso discrezionale, prima di stabilire se un'operazione è lecita, è necessario consultare una tabella soggetti-oggetti"
    ],
    "correct": "d",
    "question": "27) Quale delle seguenti affermazioni sul controllo di accesso è vera?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Se uno scheduler è non-preemptive, permette sempre ai suoi processi di essere eseguiti sul processore, senza interruzioni, fino al loro completamento",
      "Se uno scheduler è non-preemptive, è possibile che un processo monopolizzi il processore, anche in presenza di altri processi ready",
      "Se uno scheduler è preemptive, non è possibile che un processo monopolizzi il processore, anche in presenza di altri processi ready",
      "Per avere un trattamento equo sui processi, è sufficiente usare uno scheduler preemptive"
    ],
    "correct": "b",
    "question": "28) Assumendo un sistema monoprocessore, quale delle seguenti affermazioni sulla preemption è vera?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Con lo scheduler Shortest Process Next, i processi con una grande immagine su RAM potrebbero soffrire di starvation",
      "Lo scheduler round-robin virtuale migliora il round-robin classico, facendo sì che i processi I/O-bound non vengano sfavoriti",
      "Lo scheduler First Come First Served \"degenera\" nello scheduler round-robin se il quanto di tempo è troppo lungo",
      "Nessuna delle altre opzioni è vera"
    ],
    "correct": "b",
    "question": "29) Assumendo un sistema monoprocessore, quale delle seguenti affermazioni sugli algoritmi di scheduling è vera?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Un indirizzo ﬁsico fa sempre riferimento alla memoria secondaria",
      "Per rispettare il requisito di rilocazione, occorre trasformare indirizzi ﬁsici in logici",
      "Gli indirizzi relativi sono usati nella paginazione",
      "Nessuna delle altre opzioni è corretta"
    ],
    "correct": "d",
    "question": "30) Quale delle seguenti affermazioni sugli indirizzi di memoria principale è vera?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Una sezione critica è una porzione di memoria che contiene almeno una variabile condivisa tra più processi",
      "Una operazione atomica è una sequenza di istruzioni macchina tale che, se un processo la esegue, allora arriverà a termine senza interruzioni da altri processi",
      "Il requisito di mutua esclusione prevede che un solo processo possa eseguire un certo segmento di codice o accedere ad una determinata risorsa",
      "Una race condition è una violazione della mutua esclusione || È possibile che 2 distinti processi chiamino la stessa funzione atomica"
    ],
    "correct": "a",
    "question": "31) Quale delle seguenti affermazioni sui termini tipici della concorrenza è falsa?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Nessuna delle altre opzioni contiene elementi del process control block",
      "Le informazioni sul contesto del processo, aggiornate ad ogni istruzione eseguita",
      "L'intera immagine del processo in memoria",
      "La tabella delle pagine di secondo livello"
    ],
    "correct": "a",
    "question": "32) Quale dei seguenti elementi fa parte del process control block?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "L'utente che ha creato il ﬁle",
      "La data di creazione del ﬁle",
      "Autorizzazioni per l'accesso al ﬁle",
      "Dimensione del ﬁle"
    ],
    "correct": "a",
    "question": "33) Quale delle seguenti informazioni non è presente in una tipica entry di una directory di un ﬁle system?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "L'algoritmo random ha la stessa funzione dell'algoritmo ottimo dei rimpiazzamenti di pagina: ha delle prestazioni ottime non raggiungibili dagli altri algoritmi",
      "Nessuna delle altre opzioni è corretta",
      "L'algoritmo C-SCAN deriva da SCAN, ed è stato sviluppato per evitare di favorire le richieste di tracce ai bordi del disco",
      "Per valutare le prestazioni dell'algoritmo con priorità è necessario fornire il ruolo dell'utente"
    ],
    "correct": "c",
    "question": "34) Quale delle seguenti affermazioni sugli algoritmi di scheduling per i dischi è vera?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Nessuna delle altre opzioni è corretta",
      "L'algoritmo C-SCAN deriva da SCAN, ed è stato sviluppato per evitare di favorire le richieste di tracce ai bordi del disco",
      "Per valutare le prestazioni dell'algoritmo con priorità è sufficiente fornire il ruolo degli utenti dei processi che effettuano le richieste",
      "L'algoritmo random ha la stessa funzione dell'algoritmo ottimo dei rimpiazzamenti di pagina: ha delle prestazioni ottime non raggiungibili dagli altri algoritmi"
    ],
    "correct": "b",
    "question": "35) Quale delle seguenti affermazioni sugli algoritmi di scheduling per i dischi è vera?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "È possibile che ci sia frammentazione interna",
      "La compattazione permette di memorizzare file che altrimenti non potrebbero esserlo (pur essendo la loro dimensione minore di quella dello spazio libero)",
      "Non è necessaria la preallocazione",
      "La tabella di allocazione dei file necessita di memorizzare, per ogni file, il solo blocco di partenza"
    ],
    "correct": "b",
    "question": "36) Quale delle seguenti affermazioni sul metodo di allocazione contigua dei file è vera? ",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Frame e pagine devono avere la stessa dimensione",
      "Tutte le pagine di un processo dovranno essere, prima o poi, posizionate in un frame",
      "Nessuna delle altre opzioni è corretta",
      "Soffre del problema della frammentazione interna, e quindi necessita compattazione"
    ],
    "correct": "a",
    "question": "37) Quale delle seguenti affermazioni sulla paginazione della memoria è vera? ",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Nel controllo di accesso basato su ruoli, ad ogni ruolo è assegnato un utente",
      "Nel controllo di accesso basato su ruoli, prima di stabilire se un'operazione è lecita, è necessario consultare una tabella soggetti-ruoli-oggetti",
      "Nel controllo di accesso discrezionale, prima di stabilire se un'operazione è lecita, è necessario consultare una tabella soggetti-oggetti",
      "Nessuna delle altre opzioni è vera"
    ],
    "correct": "c",
    "question": "38) Quale delle seguenti affermazioni sul controllo di accesso è vera? ",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Nel caso delle risorse riusabili, in un grafo dell'allocazione delle risorse ci possono essere più archi tra lo stesso nodo-processo e lo stesso nodo-risorsa",
      "Nel caso delle risorse riusabili, in un grafo dell'allocazione delle risorse ci possono essere archi sia da nodi-processi a nodi-risorse che viceversa",
      "Un grafo dell'allocazione delle risorse è un grafo diretto aciclico",
      "In un grafo dell'allocazione delle risorse, all'interno di un nodo rappresentante una risorsa, c'è un pallino per ogni istanza di quella risorsa"
    ],
    "correct": "c",
    "question": "39) Quale delle seguenti affermazioni è falsa? ",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "La confidenzialità di un sistema operativo consiste nel fatto che la shell del sistema operativo deve essere intuitiva e dare del tu agli utenti",
      "La disponibilità (availability) di un sistema operativo consiste nel fatto che il sistema operativo deve essere sempre pronto a rispondere alle richieste di un utente",
      "La disponibilità (availability) di un sistema operativo consiste nel fatto che devono esistere delle repository online che permettano sia di installare che di aggiornare il sistema operativo",
      "La confidenzialità di un sistema operativo consiste nel fatto che il sistema operativo deve essere sempre pronto a rispondere alle richieste di un utente"
    ],
    "correct": "b",
    "question": "40) Quali delle seguenti affermazioni è vera? ",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Il difetto principale del prepaging è che potrebbe portare in memoria pagine cui poi non si fa riferimento",
      "Nessuna delle altre opzioni è corretta",
      "Il difetto principale del paging on demand è che, dopo una prima fase di assestamento, causa molti page fault",
      "Placement policy e replacement policy sono sinonimi ed indicano lo stesso insieme di metodologie"
    ],
    "correct": "a",
    "question": "41) Quale delle seguenti affermazioni sulla memoria virtuale con paginazione è vera? ",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Nessuna delle altre opzioni è corretta",
      "Un settore di un disco magnetico a testina mobile è l'area di una corona circolare del disco stesso",
      "Una traccia di un disco magnetico a testina mobile è l'area compresa da 2 raggi del disco stesso",
      "Per selezionare un settore su una traccia di un disco magnetico a testina mobile, è sufficiente posizionare la testina sulla giusta traccia"
    ],
    "correct": "a",
    "question": "42) Quale delle seguenti affermazioni sui dispositivi di memoria di massa è vera? ",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Semafori generali e semafori binari hanno lo stesso potere computazionale (ovvero, permettono di risolvere gli stessi problemi)",
      "Le primitive sui semafori sono in grado di mettere un processo in blocked, senza usare, a tal proposito, il busy-waiting",
      "Per implementare le primitive sui semafori, servono un contatore ed una coda, che saranno condivisi da tutti i semafori usati",
      "L'implementazione delle primitive sui semafori è garantita atomica dal sistema operativo"
    ],
    "correct": "c",
    "question": "44) Quale delle seguenti affermazioni sui semafori per la gestione della concorrenza è falsa? ",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Nell'algoritmo F-SCAN, immediatamente prima che vengano scambiati i contenuti delle code F ed R, la coda F è vuota, mentre la coda R contiene le richieste arrivate mentre si servivano le richieste dentro F",
      "L'algoritmo Minimum Service Time può portare alla starvation di un processo, che non verrà quindi mai selezionato, se la richiesta era bloccante, per andare in esecuzione sul processore",
      "L'algoritmo LIFO è il più equo nei confronti dei processi che effettuano le richieste al disco",
      "Gli algoritmi Minimum Service Time, SCAN, C-SCAN, N-steps-SCAN ed F-SCAN non sono ottimizzati per essere usati su dischi con testine multiple selezionabili elettronicamente"
    ],
    "correct": "c",
    "question": "45) Quale delle seguenti affermazioni sugli algoritmi di scheduling per i dischi è falsa? ",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Senza usare né semafori, né scambio messaggi, né istruzioni macchina atomiche, è possibile scrivere processi che non soffrano di starvation per garantire la mutua esclusione tra 2 processi",
      "Disabilitando gli interrupt, è possibile scrivere processi che non soffrano di starvation",
      "Usando i semafori di qualsiasi tipo, è possibile scrivere processi che non soffrano di starvation",
      "Usando le istruzioni macchina exchange e compare_and_swap, è possibile scrivere processi che non soffrano di starvation"
    ],
    "correct": "a",
    "question": "46) Quale delle seguenti affermazioni sui meccanismi per la gestione della concorrenza è vera? ",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Decide quali processi, tra quelli appena creati, possono essere ammessi in memoria principale per l'esecuzione",
      "Avendo le necessarie informazioni, una tipica strategia è mantenere una giusta proporzione, stabilita a priori, tra processi I/O-bound e CPU-bound",
      "Viene chiamato in causa esclusivamente quando viene creato un nuovo processo",
      "Avendo le necessarie informazioni, una tipica strategia è ammettere in memoria principale i processi che richiedono dispositivi di I/O diversi da quelli richiesti dai processi già attivi"
    ],
    "correct": "c",
    "question": "47) Assumendo un sistema monoprocessore, quale delle seguenti affermazioni sul long-term scheduler è falsa? ",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Se ci sono blocchi da 1kB, e il disco contiene 1TB, l'occupazione dovuta alla lista di blocchi liberi è dell'1%",
      "Se viene usata la lista di blocchi liberi, tale lista viene interamente mantenuta in memoria principale",
      "Nessuna delle altre opzioni è vera",
      "Se viene usata la lista di blocchi liberi, c'è un overhead di spazio, contrariamente alla concatenazione di blocchi liberi"
    ],
    "correct": "d",
    "question": "48) Quale delle seguenti affermazioni sui metodi di gestione dello spazio libero su disco è vera? ",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "È sempre necessario identificare un file di un file system fornendone il path relativo alla directory corrente",
      "È sempre possibile dare lo stesso nome a file diversi",
      "Nessuna delle altre opzioni è vera",
      "È sempre necessario identificare un file di un file system fornendone il path assoluto"
    ],
    "correct": "c",
    "question": "49) Quale delle seguenti affermazioni sulle directory di un file system è vera?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "La memoria cache è direttamente indirizzabile in assembler",
      "Nessuna delle altre opzioni è corretta",
      "È possibile che, in un dato istante, la cache e la memoria RAM non siano coerenti tra loro",
      "L'algoritmo di rimpiazzamento per la cache stabilisce quale blocco di RAM deve essere sostituito da un blocco di cache"
    ],
    "correct": "c",
    "question": "50) Quale delle seguenti affermazioni sulla memoria cache è vera? ",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Per il problema dei produttori/consumatori, non deve essere mai possibile che più consumatori accedano contemporaneamente al buffer, mentre nel problema dei lettori/scrittori deve sempre possibile che più lettori, in assenza di scrittori, accedano all'area di memoria",
      "Per il problema dei produttori/consumatori, non deve essere mai possibile che più produttori accedano contemporaneamente al buffer, mentre nel problema dei lettori/scrittori deve essere sempre possibile che più scrittori (in assenza di lettori) accedano all'area di memoria",
      "Nessuna delle altre opzioni è corretta",
      "Per il problema dei produttori/consumatori, deve essere sempre possibile che più consumatori accedano contemporaneamente al buffer, mentre nel problema dei lettori/scrittori non deve essere mai possibile che più scrittori accedano all'area di memoria"
    ],
    "correct": "a",
    "question": "51) Quale delle seguenti affermazioni sui problemi dei produttori/consumatori e dei lettori/scrittori, nelle accezioni viste a lezione, è vera? ",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Può essere usato per determinare quando uno dei due processi sperimenta un page fault",
      "Può essere usato per visualizzare le possibilità di deadlock, ma solo se i processi richiedono al massimo 2 risorse",
      "Nessuna delle altre opzioni è vera",
      "Può essere usato per determinare quando uno dei due processi manda un segnale all'altro"
    ],
    "correct": "c",
    "question": "52) Quale delle seguenti affermazioni, riguardanti il joint progress diagram di 2 processi, è vera? ",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Con il partizionamento fisso, le partizioni devono avere tutte la stessa dimensione",
      "Con il buddy system, ogni indirizzo di memoria può ricadere in 2 porzioni",
      "Con il partizionamento fisso, ci possono essere al massimo N processi attivi (ovvero, accettati per l'esecuzione), dove N è il numero di partizioni",
      "Con il partizionamento dinamico, si manifesta il problema della frammentazione esterna"
    ],
    "correct": "d",
    "question": "53) Quale delle seguenti affermazioni sui (vecchi) metodi per il partizionamento della memoria è vera? ",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Se uno scheduler è preemptive e vi è più di 1 processo ready, non è possibile che un processo monopolizzi il processore",
      "Per avere un trattamento equo sui processi, è sufficiente usare uno scheduler preemptive",
      "Se uno scheduler è non-preemptive, permette sempre ai suoi processi di essere eseguiti senza interruzioni sul processore fino al loro completamento",
      "Se uno scheduler è non-preemptive, è possibile che un processo monopolizzi il processore, anche in presenza di altri processi ready"
    ],
    "correct": "d",
    "question": "54) Assumendo un sistema monoprocessore, quale delle seguenti affermazioni sulla preemption è vera? ",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Blocked ==> Running",
      "Running ==> Ready",
      "Blocked ==> Exit",
      "Blocked ==> Ready"
    ],
    "correct": "a",
    "question": "55) Nel modello dei processi a 5 stati, quali delle seguenti transizioni non è possibile? ",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Il consolidamento permette sempre di ridurre la dimensione dell'indice",
      "Se usato con porzioni di dimensione variabile, i blocchi indice devono contenere anche la lunghezza di ogni porzione",
      "Nessuna delle altre opzioni è vera",
      "Non c'è modo per il sistema operativo di distinguere tra blocchi con dati e blocchi con indici"
    ],
    "correct": "b",
    "question": "56) Quale delle seguenti affermazioni sul metodo di allocazione indicizzata dei file è vera? ",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Nessuna delle altre opzioni è corretta",
      "Se viene realizzato tramite sostituzione degli indirizzi nel programma sorgente (al momento della creazione del processo), allora il relativo processo dovrà cominciare sempre allo stesso indirizzo; tale indirizzo dovrà essere uguale per tutti i processi",
      "Se viene realizzato tramite sostituzione degli indirizzi nel programma sorgente (al momento della creazione del processo), allora il relativo processo potrà trovarsi in diverse posizioni della memoria in diversi momenti del sua esecuzione",
      "Se viene realizzato tramite sostituzione degli indirizzi nel programma sorgente (al momento della creazione del processo), serve hardware speciale"
    ],
    "correct": "a",
    "question": "57) Quale delle seguenti affermazioni sul requisito di rilocazione nella gestione della memoria è vera? ",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Se uno scheduler è non-preemptive, permette sempre ai suoi processi di essere eseguiti sul processore, senza interruzioni, fino al loro completamento",
      "Se uno scheduler è non-preemptive, è possibile che un processo monopolizzi il processore, anche in presenza di altri processi ready",
      "Se uno scheduler è preemptive, non è possibile che un processo monopolizzi il processore, anche in presenza di altri processi ready",
      "Per avere un trattamento equo sui processi, è sufficiente usare uno scheduler preemptive"
    ],
    "correct": "b",
    "question": "58) Assumendo un sistema monoprocessore, quale delle seguenti affermazioni sulla preemption è vera?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Non deve essere fatta alcuna assunzione sulla velocità di esecuzione dei processi coinvolti",
      "Se un processo non fa richiesta di entrare nella sezione critica, deve comunque sincronizzarsi all'esecuzione degli altri processi",
      "Se un processo è nella sezione critica, occorre che rilasci subito la sezione critica stessa",
      "Se un processo fa richiesta di entrare nella sezione critica, deve poter entrare subito nella sezione critica stessa"
    ],
    "correct": "a",
    "question": "59) Quale dei seguenti requisiti deve soddisfare un meccanismo che offra la mutua esclusione? ",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Il resource balancing è un criterio di sistema non prestazionale",
      "Il rispetto delle deadline è un criterio utente prestazionale",
      "Il throughput è un criterio di sistema prestazionale",
      "La predictability è un criterio utente prestazionale"
    ],
    "correct": "d",
    "question": "60) Assumendo un sistema monoprocessore, quale delle seguenti affermazioni sul dispatcher è falsa? ",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Devono essere gestiti da opportuno software di sistema",
      "Una volta gestito l'interrupt o l'eccezione, quando (e se) si torna ad eseguire il processo interrotto, l'esecuzione ripartirà sempre dall'istruzione successiva a quella dove è stato ricevuto l'interrupt o l'eccezione",
      "Normalmente, non vengono gestiti dal programmatore dell'applicazione che li ha causati",
      "Possono essere creati direttamente dai dispositivi di I/O"
    ],
    "correct": "b",
    "question": "61) Quale delle seguenti affermazioni sugli interrupt (o eccezioni) è falsa? ",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Sono basate sul busy-waiting, ovvero sul fatto che un processo si mette autonomamente in stato blocked",
      "Nessuna delle altre opzioni è vera",
      "Non riescono ad evitare il manifestarsi del deadlock, a meno che non sia presente un sistema a priorità",
      "Come per la disabilitazione delle interruzioni, non funzionano per architetture con più processori o core"
    ],
    "correct": "b",
    "question": "62) Quale delle seguenti affermazioni sulle istruzioni macchina speciali per la gestione della concorrenza è vera? ",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Nessuna delle altre opzioni è vera",
      "Per la terminazione normale di un processo, è tipicamente prevista un'apposita system call, come ad esempio exit",
      "Un processo può morire quando si effettua il process spawning",
      "Un processo può essere creato dal modulo di gestione della memoria per gestire la traduzione da indirizzi virtuali a fisici"
    ],
    "correct": "b",
    "question": "63) Quale delle seguenti affermazioni sui processi è vera? ",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Sia l'algoritmo di Dekker che quello di Peterson possono mettere in blocked uno dei 2 processi, quando ciò si rivela necessario",
      "Sia l'algoritmo di Dekker che quello di Peterson non funzionano se l'hardware sottostante riordina gli accessi in memoria",
      "Nell'algoritmo di Peterson, se la variabile turn è inizializzata ad 1, allora il processo 1 sarà sicuramente il primo ad entrare nella sezione critica nella prima iterazione",
      "Nell'algoritmo di Dekker, se la variabile turn è inizializzata ad 1, allora il processo 1 sarà sicuramente il primo ad entrare nella sezione critica nella prima iterazione"
    ],
    "correct": "b",
    "question": "64) Quale delle seguenti affermazioni sui meccanismi software per la gestione della concorrenza è vera? ",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Ogni directory è identificata da un i-node",
      "Per modificare una directory, un utente deve aprire il file speciale corrispondente e poi modificarlo opportunamente",
      "Ogni directory è un file speciale, organizzato come una lista di entry, ciascuna delle quali contiene il nome di un file ed il relativo i-node number",
      "Ogni directory può contenere molti i-node"
    ],
    "correct": "b",
    "question": "65) Quale delle seguenti affermazioni sugli i-node di Unix è falsa? ",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Nel caso di un sistema operativo a kernel separato, la gestione dei process switch è a sua volta un processo",
      "Nel caso di un sistema operativo in cui le funzioni del sistema operativo vengono eseguite all'interno dei processi utente, non c'è bisogno di un process switch per eseguire una funzionalità del sistema operativo",
      "Nel caso di un sistema operativo in cui le funzioni del sistema operativo vengono eseguite all'interno dei processi utente, se un processo effettua una syscall e poi può continuare ad essere eseguito, non avviene alcun process switch",
      "Nel caso di un sistema operativo in cui le funzioni del sistema operativo vengono eseguite come processi separati, c'è sempre bisogno di un process switch per eseguire una funzionalità del sistema operativo"
    ],
    "correct": "a",
    "question": "66) Quale delle seguenti affermazioni è falsa? ",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "La differenza tra paginazione semplice e paginazione con memoria virtuale è che nella seconda viene richiesto che tutte le pagine di un processo siano in memoria principale, affinché il processo stesso possa essere eseguito",
      "Con la paginazione con memoria virtuale, una sola pagina di ogni processo ready o in esecuzione è inizialmente caricata in memoria principale",
      "La differenza tra paginazione semplice e paginazione con memoria virtuale è che nella prima viene richiesto che tutte le pagine di un processo siano in memoria principale, affinché il processo stesso possa essere eseguito",
      "Nessuna delle altre opzioni è vera"
    ],
    "correct": "c",
    "question": "67) Quale delle seguenti affermazioni sulla paginazione della memoria è vera? ",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Il consolidamento permette di memorizzare file che altrimenti non potrebbero esserlo (pur essendo la loro dimensione minore di quella dello spazio libero)",
      "La tabella di allocazione dei file deve contenere l'intera catena",
      "Nessuna delle altre opzioni è vera",
      "Viene usato con porzioni di dimensione variabile, ma piccola"
    ],
    "correct": "c",
    "question": "68) Quale delle seguenti affermazioni sul metodo di allocazione concatenata dei file è vera? ",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Nel caso di una tabella delle pagine a 2 livelli, viene tipicamente richiesto che tutte le tabelle delle pagine di secondo livello entrino in una pagina",
      "Il numero di bit di un indirizzo virtuale è necessariamente diverso a seconda che si usi una tabella delle pagine ad 1 o a 2 livelli",
      "Il numero di bit di una entry di una tabella delle pagine di ultimo livello è uguale al numero di bit di controllo più il logaritmo (arrotondato all'intero superiore) del massimo numero di frame in memoria principale",
      "Nessuna delle altre opzioni è corretta"
    ],
    "correct": "c",
    "question": "69) Quale delle seguenti affermazioni sulla memoria virtuale con paginazione è vera? ",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Affinchè ci sia un deadlock, sono necessarie le condizioni di attesa circolare, hold-and-wait, mutua esclusione e no preemption",
      "Per prevenire il deadlock, è necessario cercare di impedire almeno una delle 3 condizioni di mutua esclusione, hold-and-wait e no preemption",
      "Affinchè il deadlock sia possibile, sono necessarie le condizioni di mutua esclusione, hold-and-wait e no preemption",
      "Per prevenire il deadlock impedendo l'hold-and-wait, si può in alcuni casi imporre ai processi di richiedere tutte le risorse fin dall'inizio"
    ],
    "correct": "b",
    "question": "70) Quale delle seguenti affermazioni sul deadlock è falsa?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "La modalità di un processo utente è sempre la modalità di sistema",
      "La modalità di un processo utente è inizialmente la modalità utente; può diventare modalità sistema nel momento in cui va in esecuzione il dispatcher",
      "Nessuna delle altre opzioni è vera",
      "La modalità di un processo utente è sempre la modalità utente"
    ],
    "correct": "c",
    "question": "71) Quale delle seguenti affermazioni è vera? ",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Nessuna delle altre opzioni è corretta",
      "Per ogni processo, il resident set contiene lo stesso numero di pagine",
      "Un tipico algoritmo per il replacement scope è quello dell'orologio",
      "La gestione del resident set tramite politica dinamica mira ad ampliare il numero di pagine di un processo durante l'esecuzione del processo stesso"
    ],
    "correct": "a",
    "question": "72) Quale delle seguenti affermazioni sulla memoria virtuale con paginazione è vera? ",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "L'istruzione exchange non può ricevere costanti in input su nessun suo argomento, mentre per l'istruzione compare_and_swap questo non vale",
      "Le istruzioni speciali exchange e compare_and_swap sono garantite atomiche dal sistema operativo",
      "Per realizzare opportunamente l'istruzione compare_and_swap è sufficiente disabilitare le interruzioni",
      "Nessuna delle altre opzioni è vera"
    ],
    "correct": "a",
    "question": "74) Quale delle seguenti affermazioni sulla concorrenza tra processi o thread è vera?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Il response time è un criterio utente prestazionale",
      "Il turnaround time (normalizzato o no) è un criterio utente prestazionale",
      "Il throughput è un criterio di sistema non prestazionale",
      "La fairness è un criterio di sistema non prestazionale"
    ],
    "correct": "c",
    "question": "75)  Assumendo un sistema monoprocessore, quale delle seguenti affermazioni sul dispatcher è falsa?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Usa il metodo di allocazione contiguo",
      "Ogni cluster del disco contiene sia dati del disco che l'indirizzo del prossimo cluster (o l'indicazione che si tratta dell'ultimo cluster)",
      "La tabella di allocazione dei file contiene tante righe quanti sono i file memorizzati sul disco, più una riga speciale per i blocchi liberi",
      "Nessuna delle altre opzioni è vera"
    ],
    "correct": "d",
    "question": "76) Quale delle seguenti affermazioni sul file system FAT è vera?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Il translation lookaside buffer, su alcuni processori, contiene un campo per il PID dei processi",
      "Il translation lookaside buffer funziona correttamente solo se tutti i frame validi contenuti al suo interno fanno riferimento a pagine effettivamente in RAM, e non swappate su disco",
      "Il mapping associativo permette al translation lookaside buffer di trovare una data pagina semplicemente sommando il numero della pagina con l'indirizzo di partenza del translation lookaside buffer stesso",
      "Quando un indirizzo viene trovato nel translation lookaside buffer, non è necessario consultare la normale tabella delle pagine"
    ],
    "correct": "c",
    "question": "77) Quale delle seguenti affermazioni sulla memoria virtuale con paginazione è falsa?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Il contatore di programma",
      "La priorità",
      "I dati contenuti nella porzione di memoria a lui dedicata",
      "Informazioni sullo stato delle risorse"
    ],
    "correct": "d",
    "question": "78) Quale dei seguenti elementi non è una delle parti che definiscono un processo?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Nel caso delle risorse consumabili, se c'è un deadlock allora è stata richiesta almeno una risorsa già detenuta da un altro processo",
      "Nel caso delle risorse consumabili, se c'è un deadlock allora c'è una successione circolare di processi, ciascuno dei quali richiede una risorsa al processo successivo, che però la deve ancora creare",
      "Nel caso delle risorse riusabili, se c'è un deadlock allora è stata richiesta almeno una risorsa non ancora creata",
      "Nel caso delle risorse riusabili, se c'è un deadlock allora c'è una successione circolare di processi, ciascuno dei quali richiede una risorsa al processo successivo, che però la deve ancora creare"
    ],
    "correct": "b",
    "question": "79) Quale delle seguenti affermazioni, riguardanti la classificazione delle risorse di un sistema operativo e la loro relazione con il deadlock, è vera?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Dal punto di vista del processore, ogni processo esegue sempre le proprie istruzioni senza interruzioni",
      "Per realizzare correttamente un process switch, il SO avrà necessità di usare le informazioni sul contesto contenute nel process control block",
      "Dal punto di vista di ogni processo, l'esecuzione avviene in interleaving con gli altri processi",
      "Nessuna delle altre opzioni è vera"
    ],
    "correct": "b",
    "question": "80) Si supponga che ci siano N processi attivi, giostrati da uno scheduler round-robin su un sistema monoprocessore. Quale delle seguenti affermazioni è vera?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "L'hardware deve anche cercare il numero di pagina nelle entries della tabella delle pagine del processo in esecuzione. ",
      "L'hardware deve anche estrarre dall'indirizzo virtuale il numero di pagina virtuale; tale operazione è equivalente ad una divisione intera",
      "L'hardware deve anche usare il numero di pagina per accedere alla tabella delle pagine del processo in esecuzione. A tal proposito, deve conoscere l'inizio di tale tabella, che viene definito dal software (sistema operativo). Tale indirizzo può cambiare durante l'esecuzione del processo: sta al sistema operativo mantenerlo aggiornato",
      "L'hardware deve anche usare il numero di frame ottenuto dalla tabella delle pagine per comporre, insieme con l'offset originale, l'indirizzo fisico. Tale operazione è equivalente ad uno shift seguito da una somma"
    ],
    "correct": "a",
    "question": "81) Quale delle seguenti affermazioni sulla traduzione di un indirizzo virtuale in fisico, in un sistema con memoria virtuale con paginazione (avente tabella delle pagine ad 1 livello), è falsa?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Apertura",
      "Connessione",
      "Posizionamento (seek)",
      "Lock/Unlock"
    ],
    "correct": "b",
    "question": "82) Quale delle seguenti operazioni non è tipicamente effettuata su un file?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Diversi thread di uno stesso processo condividono lo stesso thread identifier",
      "Tra le funzioni di sistema per i thread, è tipicamente prevista una funzione per bloccare e sbloccare esplicitamente i thread stessi",
      "Diversi thread di uno stesso processo condividono lo stesso process identifier",
      "Diversi thread di uno stesso processo condividono i file aperti"
    ],
    "correct": "a",
    "question": "83) Quale delle seguenti affermazioni è falsa?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Nell'algoritmo di sostituzione basato su frequenza a 3 segmenti della page cache, i contatori vengono sempre incrementati, tranne quando sono nel segmento vecchio",
      "Nell'algoritmo di sostituzione basato su frequenza a 3 segmenti della page cache, i settori che possono essere sostituiti sono solo quelli del segmento vecchio",
      "Nell'algoritmo di sostituzione basato su frequenza a 3 segmenti della page cache, l'unico segmento in cui i contatori non vengono incrementati e i settori non possono essere sostituti è quello nuovo",
      "L'algoritmo di sostituzione basato su frequenza a 3 segmenti della page cache può avere buone performance anche quando dei settori vengono acceduti spesso, ma tra il primo accesso e quelli successivi ci sono molti altri accessi ad altri settori"
    ],
    "correct": "a",
    "question": "84) Quale delle seguenti affermazioni sulla page cache è falsa?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Deve minimizzare il tempo di risposta, tenendo presenti eventuali priorità",
      "Deve servire il maggior numero di utenti possibile, tenendo presenti eventuali livelli di accesso",
      "Deve dare accesso alle risorse in modo equo ed egualitario tra tutti i processi",
      "Deve massimizzare l'uso delle risorse per unità di tempo, tenendo presenti eventuali priorità"
    ],
    "correct": "c",
    "question": "85) Quali delle seguenti affermazioni sulla efficienza di un sistema operativo è falsa?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Nessuna delle altre opzioni è vera",
      "L'unico metodo, che richiede di conoscere in anticipo il massimo numero di risorse che un processo dovrà chiedere, è quello per rilevare il deadlock",
      "Il metodo più permissivo nei confronti delle richieste di risorse è quello che consiste nel prevenire il deadlock",
      "L'unico metodo che non prevede mai la preemption delle risorse è quello che evita il deadlock"
    ],
    "correct": "d",
    "question": "88) Quale delle seguenti affermazioni sui metodi di gestione del deadlock è vera?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Lo scheduler ha, tra i suoi obiettivi, quello dell'equità tra i processi, a meno che non siano definite delle priorità",
      "Lo scheduler va scritto in modo che il suo overhead sia basso",
      "Lo scheduler ha, tra i suoi obiettivi, quello di evitare il deadlock",
      "Lo scheduler ha, tra i suoi obiettivi, quello di massimizzare il volume di lavoro dei processi nel tempo"
    ],
    "correct": "c",
    "question": "89) Assumendo un sistema monoprocessore, quale delle seguenti affermazioni è falsa?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Con l'assegnamento statico, si dà un processore a caso tra quelli liberi ai processi che mantengono un uso della RAM pressoché costante",
      "Assegnando i processi del sistema operativo con l'assegnamento dinamico, si rischia di creare un bottleneck su un solo processore",
      "Uno svantaggio dell'assegnamento statico è il suo overhead maggiore rispetto a quello dinamico",
      "Nessuna delle altre opzioni è vera"
    ],
    "correct": "d",
    "question": "90) Quale delle seguenti affermazioni sugli scheduler per architetture multiprocessore è vera?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "La matrice C - A può contenere elementi negativi, ma le matrici C ed A contengono solo elementi non negativi",
      "Richiede in input, per ogni processo p e per ogni risorsa r, il numero massimo di istanze di r che p chiederà nel corso della sua esecuzione",
      "All'inizio e alla fine di ogni invocazione dell'algoritmo, Vi = Ri - ∑j = 1, ..., nAi, j",
      "Se si procede da uno stato ad un altro, necessariamente è stata fatta almeno una richiesta ad almeno una risorsa da parte di almeno un processo"
    ],
    "correct": "a",
    "question": "91) Quale delle seguenti affermazioni sull'algoritmo del banchiere per evitare il deadlock visto a lezione è falsa?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Il throughput è definito come il numero di processi completati per unità di tempo",
      "Il turnaround time è definito, per un dato processo, come il tempo che intercorre tra la sua prima esecuzione sul processore e il suo completamento",
      "Un dispatcher con buone prestazioni sul response time deve tipicamente sia minimizzare il valore medio di sistema del response time, sia massimizzare il numero di utenti con un basso valore per il response time",
      "Il processor utilization è definito come il rapporto tra il tempo in cui il processore viene usato ed il tempo totale del sistema"
    ],
    "correct": "b",
    "question": "92) Assumendo un sistema monoprocessore, quale delle seguenti affermazioni sul dispatcher è falsa?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Per ogni file-system su disco organizzato con i-node, tutti gli i-node di tutti i file su tale file-system sono memorizzati esclusivamente su disco",
      "I puntatori a tripla indirezione di un i-node vengono usati solo se la dimensione del file lo richiede",
      "Nessuna delle altre opzioni è vera",
      "Ad ogni file effettivamente memorizzato su disco può essere associato un solo numero di i-node"
    ],
    "correct": "b",
    "question": "93) Quale delle seguenti affermazioni sugli i-node di Unix è vera?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Nessuna delle altre opzioni è vera",
      "Gli stati Ready, New e Blocked del modello a 5 stati vengono sdoppiati, e ne viene creata una versione Suspend",
      "Un processo è Suspend quando scade il timeout del dispatcher",
      "È possibile la transizione Ready/Suspend ==> Blocked/Suspend"
    ],
    "correct": "a",
    "question": "94) Quale delle seguenti affermazioni sul modello dei processi a 7 stati è vera?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Per selezionare un settore su una traccia di un disco magnetico a testina mobile, bisogna prima far ruotare il disco fino ad arrivare alla giusta traccia, e poi posizionare la testina sul giusto settore",
      "Una traccia di un disco è l'area compresa tra 2 raggi del disco stesso",
      "Il tempo di accesso ad un disco magnetico a testina mobile tiene conto sia del tempo che occorre per posizionare la testina che del tempo che occorre per far ruotare il disco, ma non del tempo che occorre per effettuare effettivamente il trasferimento di dati",
      "Nessuna delle altre opzioni è corretta"
    ],
    "correct": "c",
    "question": "95) Quale delle seguenti affermazioni sui dischi magnetici a testina mobile è vera? ",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "L'exponential averaging permette di stimare la dimensione dell'immagine di un processo, a partire dalle precedenti immagini di quello stesso processo",
      "La funzione di decisione dello scheduler Highest Response Ratio Next considera tanto il tempo di esecuzione stimato quanto il tempo trascorso in attesa",
      "L'exponential averaging è una tecnica applicabile dal solo scheduler Short Process Next",
      "La funzione di decisione dello scheduler Shortest Remaining Time considera tanto il tempo di esecuzione richiesto quanto il tempo trascorso in attesa"
    ],
    "correct": "b",
    "question": "98) Assumendo un sistema monoprocessore, quale delle seguenti affermazioni sugli algoritmi di scheduling è vera?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Sia la tabella dei segmenti che quella delle pagine di un processo contengono, in ciascuna entry, un bit per indicare se la pagina o il segmento sono stati modificati",
      "Un indirizzo virtuale contiene anche un bit per indicare se la pagina corrispondente è o no in memoria principale",
      "La tabella delle pagine di un processo contiene una pagina speciale dove è memorizzato il process control block del processo stesso",
      "Ogni entry di una tabella delle pagine contiene un numero di pagina ed un offset"
    ],
    "correct": "a",
    "question": "100) Quale delle seguenti affermazioni è vera sulla memoria virtuale con paginazione a segmentazione?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Per avere un overhead accettabile, occorre demandare la traduzione degli indirizzi all'hardware, mentre al software resta da gestire prelievo, posizionamento e sostituzione delle pagine",
      "Per avere un overhead accettabile, occorre demandare la traduzione degli indirizzi e la politica di sostituzione delle pagine all'hardware, mentre al software resta da gestire prelievo e posizionamento delle pagine",
      "Per avere un overhead accettabile, occorre demandare all'hardware la traduzione degli indirizzi ed il prelievo, il posizionamento e la sostituzione delle pagine",
      "Per avere un overhead accettabile, occorre demandare al software anche la traduzione degli indirizzi"
    ],
    "correct": "a",
    "question": "99) Quale delle seguenti affermazioni sulla memoria virtuale con paginazione è vera?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "I sistemi time-sharing puntavano a minimizzare l'uso del processore",
      "Nei sistemi time-sharing, le direttive al sistema operativo arrivavano dai comandi digitati su terminali",
      "Nei sistemi batch, le direttive al sistema operativo arrivavano dai comandi del job control language, che erano non-interattivi",
      "I sistemi batch puntavano a massimizzare l'uso del processore"
    ],
    "correct": "a",
    "question": "96) Riguardo alle differenze tra sistemi batch e sistemi time sharing (degli anni 60/70), quale delle seguenti affermazioni è falsa? ",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Non ci sono sufficienti informazioni per determinare come si comporterebbe l'algoritmo di scheduling a feedback classico di Unix",
      "Non ci sono sufficienti informazioni per determinare come si comporterebbe l'algoritmo di scheduling Virtual Round-Robin",
      "Non ci sono sufficienti informazioni per determinare come si comporterebbe l'algoritmo di scheduling Round-Robin",
      "Non ci sono sufficienti informazioni per determinare come si comporterebbe l'algoritmo di scheduling SRT"
    ],
    "correct": "d",
    "question": "12) Considerare un insieme di cinque processi P1, P2, P3, P4, P5 con i seguenti tempi di arrivo e tempi di esecuzione in millisecondi: Quale delle seguenti affermazioni è falsa?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Gli unici 2 processi che non sono serviti subito (ovvero, appena arrivati) sono P3 e P5",
      "Il tempo medio di attesa è tra 10 ed 11 ms",
      "Il processo con il più lungo tempo di attesa è P1",
      "Il tempo medio di turnaround è tra 2 e 3 ms"
    ],
    "correct": "a",
    "question": "13) Considerare un insieme di cinque processi P1, P2, P3, P4, P5 con i seguenti tempi di arrivo e tempi di esecuzione in millisecondi: Assegnare questo insieme di processi ad un processore usando l'algoritmo di scheduling SRT, ﬁno a che non terminano tutti. Quale delle seguenti affermazioni è falsa?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "La soluzione non implementa correttamente la mutua esclusione, ma può essere corretta nel seguente modo: int bolt = 0; void P(int i) { int key; while(true) { do (exchange(key, bolt) == 0) while(key != 0); critical_section(); bolt = 0; key = 1; } } ",
      "La soluzione non implementa correttamente la mutua esclusione, in quanto key deve essere una variabile globale",
      "La soluzione non implementa correttamente la mutua esclusione, ma può essere corretta nel seguente modo: int bolt = 0; void P(int i) { int key; while(true) { key = 1; do (exchange(key, bolt) == 0) while(key != 0); critical_section(); bolt = 0; } } ",
      "La soluzione implementa correttamente la mutua esclusione"
    ],
    "correct": "c",
    "question": "101) Si consideri il seguente modo di implementare la mutua esclusione: Quale delle seguenti affermazioni è vera?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Diminuire la dimensione delle pagine ha effetti positivi sul numero di pagine che possono trovarsi in memoria principale",
      "Aumentare la dimensione delle pagine ha effetti positivi sulla frammentazione interna",
      "Diminuire la dimensione delle pagine ha effetti negativi sulla dimensione della tabella delle pagine",
      "Aumentare la dimensione delle pagine ha effetti negativi sulla multiprogrammazione"
    ],
    "correct": "b",
    "question": "103) Quale delle seguenti affermazioni sulla memoria virtuale con paginazione è falsa?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "La disabilitazione delle interruzioni impedisce la creazione di nuove interruzioni",
      "Se un processo utente può disabilitare le interruzioni tramite un'istruzione macchina dedicata, allora può far diminuire l'uso utile del processore",
      "La disabilitazione delle interruzioni non funziona ai fini della concorrenza (gestione sezioni critiche) su sistemi con più processori o più core",
      "L'abuso della disabilitazione delle interruzioni fa diminuire la multiprogrammazione, a parità di numero di processi"
    ],
    "correct": "a",
    "question": "104) Quale delle seguenti affermazioni sulla concorrenza tra processi o thread è falsa?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "il kernel rimane in memoria durante l'intera sessione del computer",
      "il kernel è costituito da vari moduli che non possono essere caricati nel sistema operativo in esecuzione",
      "il kernel è la prima parte del sistema operativo a essere caricata in memoria durante l'avvio",
      "Il kernel è il programma che costituisce il nucleo centrale del sistema operativo."
    ],
    "correct": "b",
    "question": "105) Quale delle seguenti affermazioni non è vera?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "In RAM, o in un livello qualsiasi della cache o nella memoria secondaria o nei registri CPU",
      "In RAM o in un livello qualsiasi della cache o nei registri CPU",
      "Nella cache di livello 1 (L1 cache) o nei registri CPU",
      "Nei registri della CPU"
    ],
    "correct": "d",
    "question": "106) In generale, la CPU puo’ eseguire un'istruzione soltanto quando gli operandi si trovano:",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Un campo dello stato di un processo che definisce quali operazioni di controllo dei dispositivi a blocchi sono state fatte dal processo",
      "Una struttura dati mantenuta dal sistema operativo che contiene tutte le informazioni necessarie all’esecuzione, sospensione e ripresa dell’esecuzione di un processo",
      "Una struttura dati mantenuta dal sistema operativo che contiene l’intera immagine di un processo",
      "Un’interfaccia di controllo dei processi del sistema operativo"
    ],
    "correct": "b",
    "question": "107) Il PCB (Process Control Block) e’:",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Il sistema operativo deve effettuare un process switch ed un mode switch per eseguire la funzione richiesta",
      "Il sistema operativo deve effettuare soltanto un process switch per eseguire la funzione richiesta",
      "Il sistema operativo deve effettuare soltanto un mode switch per eseguire la funzione richiesta",
      "Il sistema operativo deve creare un nuovo processo e fare switch ad esso per eseguire la funzione richiesta"
    ],
    "correct": "c",
    "question": "108) Considera un Sistema Operativo con esecuzione all’interno dei processi utente. Quando un processo utente fa una chiamata di sistema, quale delle seguenti affermazioni e’ corretta",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Il dispatcher e’ una componente del medium term scheduler",
      "Il dispatcher si occupa di decidere l’ordine di sospensione dei processi",
      "Il dispatcher si occupa di scambiare i processi in esecuzione sulla CPU (process switch)",
      "Il dispatcher si occupa di scambiare i processi dalla memoria principale alla memoria secondaria"
    ],
    "correct": "c",
    "question": "109) Quale delle seguenti affermazioni e’ vera:",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Il sistema operativo copia immediatamente il contenuto della scrittura dalla memoria del processo direttamente alla memoria del dispositivo di I/O",
      "Il sistema operativo copia immediatamente il contenuto della scrittura dalla memoria utente alla memoria del sistema operativo, e dalla memoria del sistema operativo alla memoria del dispositivo di I/O quando piu’ opportuno",
      "Il sistema operativo copia quando piu’ opportuno il contenuto della scrittura dalla memoria del processo direttamente alla memoria del dispositivo di I/O",
      "Nessuna delle altre opzioni e’ corretta"
    ],
    "correct": "b",
    "question": "110) In un sistema operativo con I/O buffering, quando c’e’ una scrittura su dispositivo di I/O quale delle seguenti affermazioni e’ vera:",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Scrivere le richieste su disco in modo tale che il braccio meccanico si muova sempre in una direzione, fino a raggiungere l’ultima traccia, e poi torna indietro scrivendo tutte le richieste fino a raggiungere la prima traccia",
      "Puo’ portare a starvation per alcuni processi",
      "E’ meno fair (equo) dell’algoritmo SCAN",
      "Non favorisce le richieste ai bordi rispetto a SCAN"
    ],
    "correct": "d",
    "question": "111) L’algoritmo di scheduling C-SCAN:",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Ogni utente dev’essere in grado di creare, cancellare, leggere, scrivere e modificare un file",
      "Ogni utente deve poter accedere, in modo controllato, ai file di un altro utente",
      "Ogni utente deve poter mantenere una copia di backup dei propri file",
      "Tutte le opzioni sono requisiti"
    ],
    "correct": "d",
    "question": "112) Quale dei seguenti sono requisiti per un File Management System?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Che e’ racchiuso tra una coppia di operazioni di semaforo semWait e semSignal",
      "In cui si accede a risorse condivise",
      "Che evita i deadlock",
      "Che deve essere eseguito in un determinato lasso di tempo."
    ],
    "correct": "b",
    "question": "113) Una sezione critica è un segmento di programma:",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Garantisce la non-starvation",
      "Non richiede nessun supporto dal SO.",
      "Richiede supporto dal SO",
      "E' deterministico."
    ],
    "correct": "c",
    "question": "114) Quale dei seguenti NON è vero riguarda il Algoritmo di Dekker per gestire la concorrenza?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Nel Translation lookaside buffer ci sono tag e chiavi con l'aiuto dei quali viene effettuata la mappatura.",
      "Il TLB hit è una condizione in cui la voce desiderata viene trovata nel TLB.",
      "Se la voce non viene trovata nel TLB (TLB miss), la CPU deve accedere alla tabella delle pagine nella memoria principale e quindi accedere al frame effettivo nella memoria principale.",
      "Tutte le opzioni sono vere."
    ],
    "correct": "d",
    "question": "115) Quale delle affermazioni è vera riguardo al Translation lookaside buffer per la gestione della memoria?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Si occupa della decisione di quali processi debbano essere ammessi all’esecuzione nel sistema",
      "Si occupa dell’organizzazione di lungo termine dell’ordine di esecuzione dei processi nella CPU",
      "Si occupa dell’implementazione della funzione di swapping dei processi alla memoria secondaria",
      "Si occupa della transizione dei processi tra gli stati running ed exit"
    ],
    "correct": "a",
    "question": "116) Quale delle seguenti affermazioni sul long-term scheduler e’ vera:",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Un processo puo’ essere spostato allo stato suspended dallo stato blocked e ready",
      "Un processo puo’ essere spostato dallo stato running allo stato ready o exit",
      "Un processo puo’ essere spostato dallo stato blocked solo allo stato ready",
      "Un processo puo’ essere spostato dallo stato ready allo stato running, blocked o exit"
    ],
    "correct": "a",
    "question": "117) Nel modello dei processi a 5 stati, quale affermazione e’ falsa:",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "I/O programmato, perche’ consente al programmatore di fare uno scheduling esatto delle operazioni di I/O nei momenti piu’ opportuni",
      "I/O basato su DMA (Accesso Diretto alla Memoria), perche’ la CPU deve soltanto occuparsi del trasferimento dei dati",
      "I/O basato su interruzioni, perche’ il processore non deve controllare attivamente lo stato del dispositivo di I/O dopo aver effettuato la richiesta",
      "I/O basato su DMA (Accesso Diretto alla Memoria), perche’ la CPU deve soltanto occuparsi di inviare la richiesta di I/O e leggere il risultato"
    ],
    "correct": "d",
    "question": "118) Riguardo l’efficienza dal punto di vista dell’utilizzo utile della CPU, quale dei seguenti modelli di I/O e’ piu’ efficiente dal punto di vista dell’uso della CPU e perche’?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "A richiede ed ottiene accesso ad R1, B richiede ed ottiene accesso ad R2. A richiede accesso ad R2, B richiede accesso ad R1",
      "A richiede ed ottiene accesso ad R1, B richiede accesso ad R2. A richiede accesso ad R2. B richiede accesso ad R1",
      "A richiede ed ottiene accesso ad R2, B richiede accesso ad R1 ed R2. A richiede ed ottiene accesso ad R1",
      "B richiede ed ottiene accesso ad R1, A richiede ed ottiene accesso ad R2. B richiede accesso ad R2"
    ],
    "correct": "a",
    "question": "119) Dati due processi A e B e due risorse R1 ed R2, si ha sicuramente una situazione di deadlock se:",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "la preallocazione è più efficiente nell'utilizzo dello spazio su disco",
      "nessuna delle opzioni è corretta",
      "l'allocazione dinamica rischia di sprecare spazio disco in caso gli utenti/applicazioni sovrastimino la dimensione dei file, mentre questo non è il caso con la preallocazione",
      "L'allocazione dinamica impone un overhead di gestione minore per il sistema operativo"
    ],
    "correct": "b",
    "question": "120) Quali delle seguenti affermazioni e' vera riguardo la preallocazione rispetto all'allocazione dinamica dello spazio per i file?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "NTFS può, ove possibile, includere direttamente i dati di un file nella master file table",
      "NTFS non prevede la possibilità di avere record estesi",
      "nessuna delle altre opzioni è vera",
      "In NTFS, le informazioni relative alla sequenza di blocchi che contengono il file è interamente contenuta nel record base"
    ],
    "correct": "a",
    "question": "121) Quale delle seguenti affermazioni sul file system NTFS è vera?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Nei sistemi con hardware dedicato per la rilocazione, il base register (registro base) viene impostato una sola volta, quando il programma viene caricato in memoria per la prima volta",
      "In un sistema con rilocazione a run time, i sistemi di protezione che verificano che un processo non vada ad accedere alla memoria di un'altro processo possono essere eseguiti a tempo di compilazione, prima di eseguire il programma",
      "In un sistema a rilocazione con indirizzi logici, non è necessario avere hardware dedicato per effettuare la rilocazione",
      "In un sistema a rilocazione con indirizzi assoluti, se si conosce l'indirizzo di memoria dove verrà caricato il programma, il compilatore può inserire direttamente gli indirizzi di memoria corretti nel codice oggetto (programma compilato)"
    ],
    "correct": "d",
    "question": "122) Quale delle seguenti affermazioni riguardo la rilocazione degli indirizzi di memoria è vera?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Il SO impiega la maggior parte del suo tempo a swappare pezzi di processi, anziché ad eseguire istruzioni",
      "provoca il deterioramento o il crollo delle prestazioni del computer",
      "quasi ogni richiesta di pagine da luogo ad una page fault",
      "Tutte le opzioni sono vere"
    ],
    "correct": "d",
    "question": "123) Quale delle seguenti affermazioni è vera riguardo il concetto di Thrashing?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Permette di avere partizioni di lunghezza diversa e di modificarle a runtime",
      "Nessuna delle opzioni è vera",
      "Consente una efficiente della memoria se ci sono molti processi di piccole dimensioni ",
      "Impone un numero massimo di processi che possono essere in memoria principale"
    ],
    "correct": "d",
    "question": "124) Il sistema di partizionamento fisso per la memoria principale:",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Semplice da effettuare",
      "Versatilità",
      "Velocità di computazione in real time degli hash",
      "Disponibilità di molti tool per automatizzazione"
    ],
    "correct": "c",
    "question": "125) Quale delle seguenti non è un vantaggio dell’attacco dizionario?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Il tipo di processi che gestiscono",
      "La frequenza di esecuzione",
      "La lunghezza delle loro code",
      "Nessuna delle opzioni è corretta"
    ],
    "correct": "b",
    "question": "126) Nello scheduler a breve ed a lungo termine la distizione principale è:",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Riduzione dei tempi di risposta",
      "Possibilità di assegnare priorità ai lavori",
      "Aumento del throughput",
      "Riduzione dell’overhead del sistema operativo"
    ],
    "correct": "d",
    "question": "127) Quale dei seguenti NON è un vantaggio della multiprogrammazione?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Lo stack del processo",
      "Il bus di sistema",
      "Nessuno ",
      "Program Counter"
    ],
    "correct": "d",
    "question": "128) ___> fornisce l’indirizzo della prossima istruzione che deve essere eseguita dal processo corrente?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Rilasciare tutte le risorse prima di richiederne una nuova",
      "Non chiedere mai una risorsa dopo averne rilasciate altre",
      "Si definisce un ordinamento crescente delle risorse, una risorsa viene data solo se esegue quelle che il processo già detiene",
      "Richiedere e allocare tutte le risorse necessarie prima dell’esecuzione"
    ],
    "correct": "b",
    "question": "129) Quale dei seguenti NON è un valido schema di prevenzione del deadlock?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Non usa busy waiting",
      "Garantisce la non-starvation",
      "Tutte le opzioni elencate",
      "Garantisce il non-deadlock"
    ],
    "correct": "a",
    "question": "130) Quale dei seguenti NON è vero riguardo l’algoritmo di Dekker per gestire la concorrenza?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Tabella dei processi sospesi",
      "Tabelle di memoria",
      "Tabelle di controllo di accesso",
      "Tabelle di I/O"
    ],
    "correct": "a",
    "question": "131) Quale delle seguenti non è una tabella di controllo del sistema operativo?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "La cpu sospende l’esecuzione del codice corrente, ed avvia l’handler del nuovo interrupt ricevuto",
      "La cpu completa l’esecuzione del codice corrente, e successivamente avvia l’handler del nuovo interrupt ricevuto",
      "La cpu gestisce entrambi gli handler in parallelo",
      "La cpu termina (aborts,kills) l’esecuzione del codice corrente, ed avvia l’handler del nuovo interrupt ricevuto"
    ],
    "correct": "a",
    "question": "132) In un sistema con modello di interruzioni (interrupt) annidate, se un interrupt (I-2) è ricevuto durante la gestione di un altro interrupt(I-1)",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Produzione",
      "Throughput",
      "Capacità",
      "Nessuno"
    ],
    "correct": "b",
    "question": "133) Il numero di processi completati per unità di tempo è chiamato _____",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Tutte le opzioni elencate",
      "Fornire supporto per l’I/O da più utenti in contemporanea",
      "Minimizzare i dati persi o distrutti",
      "Fornire un insieme di interfacce standard per i processi utente"
    ],
    "correct": "a",
    "question": "134) Quale dei seguenti sono obiettivi per un file Management System?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "La tabella di allocazione contiene soltanto l'indirizzo di un blocco, e questo blocco contiene sempre tutte le entry per ogni porzione allocata al file",
      "La tabella di allocazione contiene l'indirizzo del primo blocco del file, e ciascun blocco contiene l'indirizzo del prossimo blocco del file",
      "La tabella di allocazione contiene soltanto l'indirizzo di un blocco, e questo blocco contiene le entry delle porzioni di file allocate oppure l'indirizzo di altri blocchi usati a loro volta per indicizzare le porzioni di file allocate",
      "La tabella di allocazione dei file contiene l'indirizzo di un blocco e la lista dei blocchi del file"
    ],
    "correct": "c",
    "question": "135) In un sistema operativo con allocazione dei file indicizzata, quale delle seguenti opzioni è vera:",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "L'algoritmo SCAN può portare a starvation delle richieste",
      "L'algoritmo FSCAN è una versione di SCAN che rimuove il problema della starvation delle richieste, ma che rende l'algoritmo meno fair rispetto a SCAN",
      "L'algoritmo Minimo Tempo di Servizio non richiede di conoscere la posizione della testina del disco per operare",
      "N-step-SCAN è una generalizzazione di FSCAN che è fair e può avere prestazioni molto simili a quelle di SCAN"
    ],
    "correct": "d",
    "question": "136) Quale delle seguenti affermazioni riguardo algoritmi di scheduling del disco è vera",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Short term scheduling",
      "Long term scheduling",
      "Disk scheduling",
      "File scheduling"
    ],
    "correct": "d",
    "question": "137) Quali dei seguenti NON è un tipo di scheduling dei sistemi operativi:",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "ai processi devono essere allocati frame di memoria necessariamente contigui per poter consentire l'esecuzione del processo",
      "il sistema operativo deve utilizzare la tabella delle pagine per tradurre gli indirizzi. Qualora una pagina non sia presente in memoria principale, il sistema la deve caricare dinamicamente per consentire il proseguimento dell'esecuzione di un processo",
      "non c'è necessità di traduzione degli indirizzi, in quanto tutte le pagine di un processo sono sempre caricate in un frame nella memoria principale",
      "nessuna delle altre opzioni è corretta"
    ],
    "correct": "d",
    "question": "138) Nei sistemi operativi che usano paginazione SEMPLICE per la gestione della memoria",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "non c'è possibilità di perdita dei dati in quanto, in caso di arresto imprevisto, il sistema operativo può usare il journal per ricostruire interamente le operazioni non andate a buon fine",
      "il sistema operativo usa il journal solo per copiare i dati prima di farne la scrittura anche nel file system, ma non lo utilizza per i metadati",
      "il sistema operativo usa il journal solo per copiare i metadati prima di aggiornare le strutture del file system, ma non lo utilizza per i dati",
      "nessuna delle opzioni è corretta"
    ],
    "correct": "c",
    "question": "139) Nei sistemi operativi che usano journaling logico",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "nessuna delle altre opzioni è corretta",
      "utilizza un sistema misto di allocazione contigua e concatenata in modo da minimizzare l'overhead di sistema e massimizzare le performance",
      "utilizza un sistema di allocazione concatenata basato sulla struttura dati conosciuta come inode",
      "usa gli inode per tenere traccia dei blocchi su disco allocati a ciascun file. Ogni inode contiene al suo interno la lista completa di tutti i blocchi su disco che compongono il file corrispondente"
    ],
    "correct": "a",
    "question": "140) Il sistema operativo linux per la gestione dei file",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "gli hard links sono dei file speciali che contengono il cammino completo sul file system di un altro file, effettivamente creando un \"puntatore\" a quel file",
      "gli hard link sono puntatori diretti al descrittore di un file (inode). Un contatore viene utilizzato per tenere traccia di quanti hard link puntino ad un determinato inode. Questo fa si che il file non possa essere cancellato fintantoché ci sono hard link che continuano a puntarlo",
      "possono esistere hard link a file non più esistenti, ad esempio se il file a cui l'hard link puntava viene cancellato",
      "nessuna delle altre risposte è corretta"
    ],
    "correct": "b",
    "question": "141) Nei sistemi Unix",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Permette al programmatore di vedere la memoria come un insieme di spazi di indirizzi",
      "Non permette di condividere dati",
      "Non permette di proteggere dati",
      "Nessuna delle opzioni è vera"
    ],
    "correct": "a",
    "question": "142) Quale delle affermazioni è vera riguardo alla Segmentazione per la gestione della memoria?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Integrità",
      "Disponibilità",
      "Confidenzialità",
      "Autenticità"
    ],
    "correct": "d",
    "question": "143) Quale opzione non appartiene alla triade della sicurezza?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Stack del processo",
      "Codice del programma",
      "Programma Bootstrap",
      "Nessuna delle opzioni e contenuta nel PCB"
    ],
    "correct": "d",
    "question": "144) Quale dei seguenti elementi non e contenuto nel Process Control Block (PCB)?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Capacità distribuita",
      "Aumentano l'affidabilità",
      "Consentono di risparmiare denaro rispetto a più sistemi singoli",
      "Tutte queste cose"
    ],
    "correct": "d",
    "question": "145) Il multiprocessore viene utilizzato perché:",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Mutua esclusione",
      "Hold-and-wait: richiesta di una risorsa quando già se ne detiene una",
      "Preemption delle risorse",
      "Attesa circolare"
    ],
    "correct": "c",
    "question": "146) Considerando solo risorse riusabili, quali delle seguenti condizioni non è necessaria per avere deadlock?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "non introduce alcun overhead nei sistemi operativi che lo usano rispetto a quelli che fanno I/O diretto senza buffering",
      "è utile per appianare le differenze tra diversi dispositivi di I/O rispetto alla loro velocità ed al tipo di trasferimento dati (blocchi, stream)",
      "richiede l'uso di buffer aggiuntivi nell'area di memoria dedicata ai dispositivi di I/O e nell'area di memoria dedicata ai processi utente, ma non nell'area del sistema operativo",
      "nessuna delle opzioni è corretta"
    ],
    "correct": "b",
    "question": "147) Il buffering dell'I/O:",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "non soffrono mai di frammentazione interna",
      "non soffrono mai di frammentazione esterna",
      "soffrono in alcuni casi di frammentazione interna, quando diversi processi a cui erano assegnate diverse aree di memoria vengono rimossi e sostituiti da altri processi con dimensioni diverse",
      "necessitano dell'uso di tecniche di compattazione della memoria per risolvere il problema della frammentazione interna"
    ],
    "correct": "a",
    "question": "148) I sistemi operativi che usano partizionamento dinamico della memoria:",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Partizionamento fisso",
      "Partizionamento dinamico",
      "Segmentazione con memoria virtuale",
      "Tutte le opzioni sono vere"
    ],
    "correct": "d",
    "question": "149) Quale dei seguenti è un tipo di partizionamento della memoria?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "La disabilitazione delle interruzioni non impedisce la creazione di nuove interruzioni, ma solo la loro gestione",
      "Se un processo utente può disabilitare le interruzioni tramite un'istruzione macchina dedicata, allora può far diminuire l'uso utile del processore",
      "La disabilitazione delle interruzioni non funziona ai fini della concorrenza (gestione sezioni critiche) su sistemi con più processori o più core",
      "Tutte le opzioni sono vere"
    ],
    "correct": "d",
    "question": "150) Quale delle seguenti affermazioni sulla concorrenza tra processi o thread è vera?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Il numero di frame dell'indirizzo fisico è contenuto già nell'indirizzo virtuale",
      "L'hardware deve usare il numero di pagina per accedere alla tabella delle pagine del processo in esecuzione. A tal proposito, deve conoscere l'inizio di tale tabella, che viene definito dal software (sistema operativo). Tale indirizzo può cambiare durante l'esecuzione del processo: sta al sistema operativo mantenerlo aggiornato",
      "L'hardware deve usare il numero della pagina per comporre, insieme con l'offset originale, l'indirizzo fisico. Tale operazione è equivalente ad uno shift seguito da una somma",
      "L'hardware deve effettuare una ricerca sequenziale del numero di pagina nelle entries della tabella delle pagine del processo in esecuzione"
    ],
    "correct": "b",
    "question": "151) Quale delle seguenti affermazioni sulla traduzione di un indirizzo virtuale in fisico, in un sistema con memoria virtuale con paginazione (avente tabella delle pagine ad 1 livello), è vera?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "utilizza un sistema di lista concatenata per tenere traccia dei blocchi del disco assegnati ai diversi file",
      "utilizza un sistema di allocazione simile all'allocazione indicizzata basato su record di attributi per ciascun file, dove un il tipo di attributo DATA contiene puntatori individuali a tutti i blocchi che compongono un dato file",
      "utilizza un sistema di allocazione simile all'allocazione indicizzata basato su record di attributi per ciascun file, dove un il tipo di attributo DATA contiene puntatori a sequenze di blocchi contigue (runs) che compongono un dato file",
      "utilizza un sistema di allocazione simile all'allocazione indicizzata simile agli inode di UNIX, in cui un campo DATA all'interno dell'inode del file contiene la sequenza completa dei blocchi che compongono un dato file"
    ],
    "correct": "c",
    "question": "152) Il file system NTFS",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "il sistema usa sempre e comunque l'allocatore di memoria standard a pagine, senza consentire richieste speciali come ad esempio allocazioni contigue di memoria. Questo per assicurarsi di evitare i problemi di frammentazione interna od esterna",
      "il sistema operativo, in casi speciali, può usare allocatori di memoria specializzati che consentano ad esempio allocazioni di porzioni di memoria contigue per richieste particolari (come ad esempio per il DMA)",
      "il sistema può modificare dinamicamente la dimensione delle pagine in base alla quantità di memoria richiesta da un processo, in modo tale da minimizzare la frammentazione interna",
      "nessuna delle altre opzioni è corretta"
    ],
    "correct": "b",
    "question": "153) Nei sistemi operativi con memoria virtuale paginata, tipicamente",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "la memoria è divisa dinamicamente a tempo di esecuzione dal sistema operativo in base alle richieste di allocazione effettuate dai processi in esecuzione",
      "la memoria viene suddivisa in un numero fisso e predefinito di partizioni, tuttavia diversi gruppi di partizioni hanno dimensioni diverse (ad es. N partizioni da 2MB, M partizioni da 4MB, e cosi via)",
      "la memoria è divisa a tempo di esecuzione dal sistema operativo in partizioni della stessa dimensione, in base alla dimensione media di memoria richiesta dai diversi processi",
      "il sistema operativo deve mantenere una tabella di traduzione degli indirizzi che consentano di tradurre un indirizzo relativo nel codice del programma ad un indirizzo assoluto, in base alla dimensione della partizione di memoria assegnatagli"
    ],
    "correct": "b",
    "question": "154) Nel sistema di partizionamento fisso variabile della memoria",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "i symbolic links sono dei simboli speciali che possono essere usati nelle chiamate di sistema per collegare le aree di memoria di diversi processi",
      "i symbolic links sono dei puntatori diretti ai descrittori di un file (inode) che consentono di creare un collegamento a quel file in una qualsiasi directory del file system",
      "ogni volta che viene creato un symbolic link tra due processi, deve essere incrementato il contatore che tiene traccia del numero di collegamenti creati. Questo per poter consentire di de-allocare le aree di memoria collegate quando tutti i processi sono terminati",
      "i symbolic links sono dei file che contengono il cammino completo sul file system di un altro file, effettivamente creando un puntatore a quel file"
    ],
    "correct": "d",
    "question": "155) Nei sistemi Unix",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "è strutturata a livelli gerarchici ed il processore può caricare i dati e le istruzioni nei registri da uno qualsiasi dei livelli della cache",
      "è strutturata a livelli gerarchici ed il processore può caricare i dati e le istruzioni nei registri solo se si trovano nel primo o secondo livello della cache",
      "non ha struttura gerarchica, in quanto una struttura piatta consente una maggior efficenza e velocità nel trasferimento dei dati",
      "è strutturata a livelli gerarchici ed il processore può caricare i dati solo dalla cache di livello 1 dati, e le istruzioni solo dalla cache livello 1 istruzioni."
    ],
    "correct": "d",
    "question": "156) Tipicamente, nei processori moderni la memoria cache",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "utilizza una lista concatenata con cluster di dimensione fissa per l'allocazione dei file",
      "utilizza una bitmap per tenere traccia dei cluster liberi sul disco",
      "occupa poco spazio di memoria, e lo spazio occupato è indipendente dalla dimensione del disco e numero dei cluster",
      "nessuna delle opzioni è corretta"
    ],
    "correct": "a",
    "question": "157) Il file system FAT32",
    "answers_have_code": 0,
    "code": ""
  }
]