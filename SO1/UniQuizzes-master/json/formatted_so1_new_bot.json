[
  {
    "answers": [
      "Coincide con il kernel",
      "Costituisce l'interfaccia tra la macchina fisica (hardware) e le applicazioni utente",
      "√à soggetto alle politiche di scheduling",
      "Risiede in memoria principale anche in seguito allo shutdown della macchina"
    ],
    "correct": "b",
    "question": "Il sistema operativo",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Alcune delle funzionalit√† sono implementate in spazio utente anzich√© all'interno del kernel",
      "I processi utente possono interagire direttamente con il sistema,evitando l'uso di system call",
      "La comunicazione tra le varie componenti del sistema √® pi√π efficiente",
      "Non sono previsti meccanismi di protezione  "
    ],
    "correct": "a",
    "question": "In un sistema operativo microkernel",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Non necessita di avere due modalit√† di utilizzo della CPU (user vs.kernel mode)",
      "Non necessita di meccanismi di comunicazione tra porzioni diverse del sistema operativo",
      "E' pi√π efficiente di un sistema monolitico",
      "Ad eccezione delle funzionalit√† fondamentali, implementa tutto il resto in spazio utente"
    ],
    "correct": "d",
    "question": "In un sistema operativo strutturato secondo un approccio microkernel",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Sono composte da un codice operativo e da zero o pi√π operandi",
      "Sono definite da uno specifico linguaggio macchina",
      "Sono un'astrazione dell'architettura hardware",
      "Tutte le risposte precedenti sono corrette"
    ],
    "correct": "d",
    "question": "L'insieme di istruzioni del livello macchina:",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Non volatili",
      "Gestite interamente dall'architettura a livello hardware",
      "Gestite interamente dal sistema operativo",
      "Molto economiche e altamente performanti"
    ],
    "correct": "b",
    "question": "I registri interni della CPU e la cache sono unit√† di memoria:",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Un programma esegue una chiamata di funzione",
      "Si avvia il computer (bootstrap)",
      "Si esegue la prima istruzione di un programma",
      "Scade il quanto di tempo assegnato al processo in esecuzione"
    ],
    "correct": "d",
    "question": "La transizione da user a kernel mode avviene quando:",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Contiene dei registri che ne indicano lo stato",
      "Contiene dei registri che ne consentono il controllo da parte della CPU",
      "Contiene dei registri per lo scambio di dati con la CPU",
      "Tutte le risposte precedenti sono corrette"
    ],
    "correct": "d",
    "question": "Il device controller di un dispositivo di I/O:",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Sono sempre bloccanti",
      "Causano la terminazione del processo in corso e l'avvio di un nuovo processo",
      "Devono essere implementate in spazio utente",
      "Devono essere implementate in spazio kernel"
    ],
    "correct": "d",
    "question": "Le chiamate di sistema:",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Sposta in coda pronti (ready) il processo che la esegue",
      "Interrompe definitivamente il processo che la esegue",
      "Interrompe temporaneamente il processo che la esegue",
      "Necessit√† che il processo che la esegue ne verifichi periodicamente l'esito (polling)"
    ],
    "correct": "c",
    "question": "Una chiamata di sistema bloccante",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "√à invocato dallo scheduler del sistema operativo",
      "Viene invocato alla scadenza del quanto temporale",
      "Viene eseguito in spazio utente",
      "Gestisce le chiamate di sistema tramite la system call table"
    ],
    "correct": "d",
    "question": "Il system call handler:",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Viene eseguito in spazio utente",
      "√à indicizzato tramite la interrupt vector table (IVT)",
      "Viene invocato alla scadenza del quanto temporale",
      "Viene invocato dallo scheduler del sistema operativo"
    ],
    "correct": "b",
    "question": " Il codice generico del system call handler:",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Si aggiorna dinamicamente ad ogni interruzione",
      "E' una struttura dati che contiene puntatori ai vari gestori(handler) delle interruzioni",
      "E' una struttura dati che √® associata a ciascun processo",
      "E' una struttura dati che contiene puntatori a codici di errori"
    ],
    "correct": "b",
    "question": "L'interrupt vector table(IVT):",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Contiene tante entry quanto sono le chiamate di sistema supportare",
      "Contiene tante entry quante sono le interruzioni supportare",
      "Contiene tante entry quanti sono i dispositivi di I/O presenti nel sistema",
      "Contiene tante entry quanti sono i processi in esecuzione"
    ],
    "correct": "a",
    "question": "La system-call table:",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Dai dispositivi di I/O",
      "Dal processo utente",
      "Sia dal kernel del sistema operativo che dal processo utente",
      "Dal kernel del sistema operativo"
    ],
    "correct": "d",
    "question": "La system-call table √® una struttura dati gestita:",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "E' sempre necessario modificare il codice utente che ne fa uso",
      "Non √® mai necessario modificare il codice utente che ne fa uso",
      "Non √® necessario modificare il codice utente che ne fa uso, a patto che cambi anche l'interfaccia (API) della chiamata di sistema",
      "Non √® necessario modificare il codice utente che ne fa uso, a patto che non cambi anche l‚Äôinterfaccia (API) della chiamata di sistema"
    ],
    "correct": "d",
    "question": "Se si cambia l'implementazione di una chiamata di sistema esistente:",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "1*10^3",
      "Decido di NON rispondere a questa domanda",
      "25*10^3",
      "1*10^6",
      "25*10^6"
    ],
    "correct": "d",
    "question": "Un processore impiega 5 cicli di clock per eseguire un'istruzione (CPI = 5), ossia per completare l'intero ciclo fetch-decode-execute. Assumendo che la frequenza di clock del processore sia pari a 5 MHz, quante istruzioni √® in grado di eseguire in un secondo? (Si ricordi che 1 MHz = 1*10^6 cicli al secondo)",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Pu√≤ essere superiore a ùëö",
      "E‚Äô esattamente pari a ùëö",
      "I dati sono insufficienti per rispondere alla domanda",
      "E' al massimo pari a ùëö"
    ],
    "correct": "d",
    "question": "Data una CPU multicore con ùëöunit√†(cores), il numero di processi/thread che ad un certo istante si trovano nella ‚Äúcoda‚Äù di esecuzione(running):",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Una chiamata di sistema",
      "Una chiamata di funzione",
      "L'invio di un interruzione",
      "Nessuna delle risposte precedenti √® corretta"
    ],
    "correct": "a",
    "question": "La creazione di un nuovo processo da parte di un processo avviene tramite:",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Un'apposita area dedicata e protetta della memoria principale",
      "Un apposito registro interno della CPU",
      "Un'apposita area dedicata e protetta della memoria cache",
      "Un apposito campo all'interno del process control block (PCB)"
    ],
    "correct": "d",
    "question": "Il sistema operativo tiene traccia dello stato di un processo tramite:",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Riceve un segnale di interruzione da parte di un dispositivo di I/O",
      "Fa richiesta di input da parte dell‚Äôutente",
      "Fa richiesta di una pagina che non √® presente in memoria principale",
      "Esegue una chiamata di funzione"
    ],
    "correct": "a",
    "question": "Un processo in esecuzione sulla CPU passa in stato ready quando:",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Riceve un segnale da parte di un dispositivo di I/O",
      "Termina il quanto di tempo ad esso assegnato",
      "Apre una connessione di rete (ad es., un socket TCP)",
      "Esegue una chiamata di funzione"
    ],
    "correct": "c",
    "question": "Un processo in esecuzione sulla CPU passa in stato waiting quando:",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Fa richiesta di input da parte dell'utente",
      "Esegue una chiamata di funzione",
      "Termina il quanto di tempo ad esso assegnato",
      "Riceve un segnale di interruzione da parte di un dispositivo di I/O"
    ],
    "correct": "a",
    "question": "Un processo in esecuzione sulla CPU passa in stato waiting quando:",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Termina il quanto di tempo ad esso assegnato",
      "L'utente trascina il dispositivo di puntamento(e.g. mouse)",
      "Esegue una chiamata di funzione",
      "Riceve un segnale di interruzione da parte di un dispositivo di I/O"
    ],
    "correct": "b",
    "question": "Un processo in esecuzione sulla CPU passa in stato waiting quando:",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "8",
      "7",
      "4",
      "3"
    ],
    "correct": "a",
    "question": "Quanti processi saranno presenti nel sistema a seguito di queste chiamata: pid_1 = fork(); pid_2 = fork(); pid_3 = fork();?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Hanno una priorit√† alta",
      "Hanno una priorit√† bassa",
      "Sono processi mediamente brevi",
      "Possono non rilasciare mai la CPU volontariamente"
    ],
    "correct": "d",
    "question": "I processi CPU-bound che non eseguono richieste di I/O:",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Quando un processo tenta di eseguire una scrittura su discord",
      "Quando il codice di un programma esegue una divisione per zero",
      "Quando scade il quanto di tempo",
      "Tutte le risposte precedenti sono corrette"
    ],
    "correct": "d",
    "question": "Lo scheduler della CPU si attiva:",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Da la priorit√† ai processi CPU-bound",
      "Si attiva solamenta alla scadenza del quanto temporale(time slice)",
      "Si attiva solamente a fronte di una chiamata di sistema",
      "Fornisce un limite superiore al tempo di CPU assegnato a ciascun processo"
    ],
    "correct": "d",
    "question": "Lo scheduling preemptive(basato su time slice o quanto temporale):",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "L'impiego dei multi-threading consente di migliorare la latenza del sistema",
      "L'impiego del multi-threading consente di diminuire il tempo di completamente di ciascun processo",
      "L'impiego del multi-threading consente di migliorare il throughput del sistema",
      "L'impiego dei multi-threading non costituisce alcun vantaggio"
    ],
    "correct": "d",
    "question": "In un sistema uniprocessore (single core) time-sharing in cui i processi in esecuzione sono tutti puramente CPU-bound:",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Quando un processo passa dallo stato running allo stato waiting",
      "Quando un processo passa dallo stato running allo stato ready",
      "Quando un processo passa dallo stato waiting allo stato ready",
      "Tutte le risposte precedenti sono corrette"
    ],
    "correct": "d",
    "question": "In caso di scheduling preemptive, lo scheduler interviene:",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "13",
      "2",
      "I dati sono insufficienti per rispondere alla domanda",
      "15"
    ],
    "correct": "a",
    "question": "Se un processo arriva nella coda dei pronti all'istante t.0 = 2e termina all'istante t.f = 15, il suo tempo di turnaround equivale a",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "3",
      "22",
      "25",
      "I dati sono insufficienti per rispondere alla domanda"
    ],
    "correct": "d",
    "question": "Se un processo arriva nella coda dei pronti all‚Äôistante ùë°0 = 3 e termina all‚Äôistante ùë°ùëì = 25, il tempo di attesa equivale a",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Lo stack",
      "Le variabili globali",
      "I valori dei registri della CPU",
      "Nessuna delle informazioni elencate sopra"
    ],
    "correct": "b",
    "question": "I thread di uno stesso processo condividono:",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Necessita del supporto di una opportuna thread table a livello kernel",
      "E' la pi√π piccola unit√† schedulabile sulla CPU dal sistema operativo",
      "E' gestito in spazio utente tramite un'apposita libreria",
      "Coincide sempre con uno ed un solo kernel thread"
    ],
    "correct": "c",
    "question": "Lo user thread:",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Consente di gestire i thread tramite un'apposita libreria a livello utente",
      "Pu√≤ essere implementato solo su sistemi multiprocessore",
      "Causa il blocco di tutti i thread di un processo se anche uno solo di questi thread esegue una chiamata di sistema bloccante",
      "Consente di gestire i thread a livello del kernel del sistema operativo"
    ],
    "correct": "d",
    "question": "Nel modello di thread mapping cosiddetto one-to-one:",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Molti user thread possono essere distribuiti su pi√π CPU (se presenti)",
      "L'effetto di una chiamata bloccante da parte di uno user thread non blocca gli altri thread da cui √® composto il processo",
      "Molti user thread sono mappati su un singolo kernel thread",
      "Molti kernel thread sono mappati su un singolo user thread"
    ],
    "correct": "c",
    "question": "Nel modello di thread mapping cosiddetto many-to-one:",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Non prevede alcun limite al numero di kernel thread",
      "Pu√≤ essere implementato solo su sistemi multiprocessore",
      "Causa il blocco di tutti i thread di un processo se anche uno solo di questi thread esegue una chiamata di sistema bloccante",
      "E' il compromesso tra un'implementazione dei thread puramente user level e una puramente kernel level"
    ],
    "correct": "d",
    "question": "Il modello di thread mapping considerato many-to-many",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Vengono eseguiti processi single-threaded su CPU multicore",
      "Vengono eseguiti processi multi-threaded su CPU single core",
      "Vengono eseguiti processi multi-threaded su CPU multicore",
      "Tutte le risposte precedenti sono corrette"
    ],
    "correct": "c",
    "question": "Si parla di parallelismo quando:",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Vengono eseguiti processi multi-threaded su CPU single core",
      "Vengono eseguiti processi single-threaded su CPU single core",
      "Vengono eseguiti processi single-threaded su CPU multicore",
      "Vengono eseguiti processi multi-threaded su CPU multicore"
    ],
    "correct": "a",
    "question": "Si parla di concorrenza quando:",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "√à pi√π lenta poich√© i thread sono gestiti da librerie di alto livello",
      "√à pi√π veloce poich√© i thread non eseguono context switch",
      "√à pi√π veloce poich√© i thread condividono lo stesso spazio di indirizzamento",
      "Non c'√® alcuna differenza sostanziale in termini di performance"
    ],
    "correct": "c",
    "question": "La comunicazione tra thread dello stesso processo rispetto a quella tra processi diversi:",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Coincide sempre con uno ed un solo user thread",
      "√à gestito in spazio utente tramite un'apposita libreria",
      "√à la pi√π piccola unit√† schedulabile sulla CPU dal sistema operativo",
      "√à il termine con cui si identificano i processi propri del sistemaoperativo (i.e., non i processi utente)"
    ],
    "correct": "c",
    "question": "Il kernel thread:",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "La lock sia inizialmente libera",
      "La lock venga acquisita prima dell'ingresso nella sezione critica",
      "La lock venga rilasciata dopo l'uscita dalla sezione critica",
      "Tutte le condizioni precedenti devono essere verificate"
    ],
    "correct": "d",
    "question": "L'uso di una primitiva di sincronizzazione lock prevede che:",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Deve avvenire in modo atomico, evitando che lo scheduler interrompa l'acquisizione",
      "Necessita obbligatoriamente del supporto di istruzioni hardware atomiche",
      "Necessita obbligatoriamente che il sistema operativo disabiliti le interruzioni",
      "Nessuna delle risposte precedenti √® corretta"
    ],
    "correct": "a",
    "question": "L'acquisizione di una lock:",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Forzare le politiche di scheduling tra processi/thread",
      "Accedere al codice del kernel",
      "Lo scambio di messaggi tra processi/thread",
      "Gestire le interruzioni che giungono alla CPU"
    ],
    "correct": "a",
    "question": "Un semaforo pu√≤ essere utilizzato per:",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Lascia invariato il valore del semaforo a 2 e fa proseguire il processo che ha eseguito l'invocazione (al netto delle politiche di scheduling)",
      "Decrementa il valore del semaforo a 1 e blocca il processo che ha eseguito l'invocazione",
      "Incrementa il valore del semaforo a 3 e fa proseguire il processo che ha eseguito l'invocazione (al netto delle politiche di scheduling)",
      "Decrementa il valore del semaforo a 1 e fa proseguire il processo che ha eseguito l'invocazione (al netto delle politiche di scheduling)"
    ],
    "correct": "d",
    "question": "L'invocazione del metodo wait() su un semaforo il cui valore √® pari a 2:",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "√à un'istruzione atomica che consente di implementare le primitive di sincronizzazione",
      "√à un'istruzione atomica che consente di disabilitare le interruzioni",
      "√à un'istruzione atomica che consente di aggiornare i valori di pi√π registri simultaneamente",
      "√à un'istruzione atomica che consente di resettare il valore di un semaforo"
    ],
    "correct": "a",
    "question": "L'istruzione test-and-set:",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Si riferiscono a codice utente e codice di sistema (rispettivamente)",
      "Nel caso di starvation tutto il sistema √® completamente bloccato",
      "Non vi √® alcuna differenza",
      "Nel caso di deadlock tutto il sistema √® completamente bloccato"
    ],
    "correct": "d",
    "question": "La differenza tra deadlock e starvation risiede nel fatto che:",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Il processo di traduzione da indirizzi logici a indirizzi fisici",
      "Il processo di inizializzazione delle variabili globali di un programma",
      "Il processo di collegamento tra il codice compilato ed eventuali librerie esterne",
      "Nessuna delle risposte precedenti √® corretta"
    ],
    "correct": "a",
    "question": "Con il termine address binding si intende:",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Implementare la rilocazione dinamica del codice di un processo",
      "Risolvere il problema della frammentazione esterna",
      "Trasferire temporaneamente su disco i processi che non sono attualmente in esecuzione",
      "Scambiare le aree di memoria occupate da due o pi√π processi"
    ],
    "correct": "c",
    "question": "Lo swapping consente di:",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Prevede che lo spazio di indirizzamento logico di un processo sia non-contiguo e suddiviso in blocchi di dimensioni fissate (pages)",
      "Non richiede alcun supporto hardware per essere implementata in modo efficiente",
      "Prevede che lo spazio di indirizzamento fisico di un processo sia non-contiguo e suddiviso in blocchi di dimensioni fissate (frames)",
      "Risolve il problema della frammentazione interna"
    ],
    "correct": "c",
    "question": "La gestione 'paginata' della memoria (paging):",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "E' condivisa tra tutti i processi del sistema",
      "Consente una traduzione mediamente pi√π rapida degli indirizzi logici",
      "Contiene un sottoinsieme delle entry della page table",
      "Tutte le risposte precedenti sono corrette"
    ],
    "correct": "d",
    "question": "La cache TLB (Translation Look-aside Buffer)",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "√à direttamente proporzionale alla dimensione (fissata) delle pagine",
      "Si adatta a seconda delle richieste di accesso alla memoria di ciascun processo",
      "Dipende dalla dimensione (fissata) delle pagine",
      "Varia dinamicamente a seconda del processo"
    ],
    "correct": "c",
    "question": "La dimensione (i.e., il numero di entry) della page table:",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Varia dinamicamente a seconda del processo",
      "E' direttamente proporzionale alla dimensione (fissata)",
      "E' inversamente proporzionale alla dimensione (fissata) delle pagine",
      "Si adatta a seconda delle richieste di accesso alla memoria di ciascun processo"
    ],
    "correct": "c",
    "question": "La dimensione (i.e., il numero di entry) della page table:",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "576",
      "552",
      "600",
      "I dati sono insufficienti per rispondere al problema"
    ],
    "correct": "d",
    "question": "Un compilatore genera l'indirizzo logico 576 per riferirsi ad una certa locazione di memoria fisica. Assumendo che la traduzione degli indirizzi avvenga tramite rilocazione statica con indirizzo fisico base = 24, quale sar√† l'indirizzo fisico corrispondente?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Allocare l'intero blocco al processo, sprecando 211 bytes(frammentazione interna)",
      " Allocare la porzione del blocco necessaria al processo e aggiungere alla lista dei blocchi liberi i 211 bytes rimanente(frammentazione esterna)",
      "Attendere che vi sia un blocco di dimensione multipla rispetto a quella del processo",
      "Attendere che vi sia un blocco di dimensione inferiore adatto a contenere il processo"
    ],
    "correct": "a",
    "question": "Si consideri un processo di dimensione pari a 2,488 bytes e un blocco di memoria libero di dimensione pari a 2,699 bytes. In questo caso, assumendo il vincolo di allocazione contigua della memoria, la scelta pi√π conveniente √®:",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Attendere che vi sia un blocco di dimensione inferiore adatto a contenere il processo",
      "Allocare l'intero blocco al processo, sprecando 20 bytes(frammentazione interna)",
      "Attendere che vi sia un blocco di dimensione multipla rispetto a quella dei processi",
      "Allocare la porzione del blocco necessaria al processo e aggiungere alla lista dei blocchi liberi i 20 bytes rimanenti(frammentazione esterna)"
    ],
    "correct": "b",
    "question": "Si consideri un processo di dimensione pari a 4,996 e un blocco di memoria libero di dimensione pari a 5,016 bytes. In questo caso, assumendo il vincolo di allocazione contigua della memoria, la scelta pi√π conveniente √®:",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "blocco A",
      "blocco C",
      "blocco B",
      "blocco D"
    ],
    "correct": "b",
    "question": "Si supponga che un processo P necessiti di un'area di memoria libera pari a 99 KiB per essere allocato in modo contiguo in memoria principale. Se la lista dei blocchi di memoria libera contiene i seguenti elementi: A, B, C, D le cui dimensioni sono rispettivamente 102 KiB, 99 KiB, 256 KiB e 128 KiB, quale blocco verr√† allocato per P assumendo una politica Worst-Fit?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "blocco B",
      "Non √® possibile soddisfare la richiesta, pertanto P dovr√† attendere",
      "C e i restati 25 KiB vengono allocati su A",
      "blocco E"
    ],
    "correct": "d",
    "question": " Si supponga che un processo P necessiti di un'area di memoria libera pari a 99 KiB per essere allocato in modo contiguo in memoria principale. Se la lista dei blocchi di memoria libera contiene i seguenti elementi: A, B, C, D, E, F le cui dimensioni sono rispettivamente 300 KiB, 600 KiB, 350 KiB, 200 KiB, 750 KiB e 125 KiB, quale blocco verr√† allocato per P assumendo una politica Worst-Fit?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "blocco A",
      "blocco D",
      "blocco B",
      "blocco C"
    ],
    "correct": "c",
    "question": "Si supponga che un processo P necessiti di un'area di memoria libera pari a 128 KiB per essere allocato in modo contiguo in memoria principale. Se la lista dei blocchi di memoria libera contiene i seguenti elementi: A, B, C, D le cui dimensioni sono rispettivamente 105 KiB, 916 KiB, 129 KiB e 80 KiB, quale blocco verr√† allocato per P assumendo una politica First-Fit?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "blocco A",
      "blocco F",
      "blocco E",
      "blocco D"
    ],
    "correct": "a",
    "question": "Si supponga che un processo P necessiti di un'area di memoria libera pari a 115 KiB per essere allocato in modo contiguo in memoria principale. Se la lista dei blocchi di memoria libera contiene i seguenti elementi: A, B, C, D,E,F le cui dimensioni sono rispettivamente 300 KiB, 600 KiB, 350 KiB, 200 KiB,750 KiB e 125 KiB quale blocco verr√† allocato per P assumendo una politica First-Fit?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "blocco B",
      "blocco C e i restanti 25 Kib vengono allocati su A",
      "blocco E",
      "Non √® possibile soddisfare la richiesta, pertanto P dovr√† attendere"
    ],
    "correct": "a",
    "question": "Si supponga che un processo P necessiti di un'area di memoria libera pari a 375 KiB per essere allocato in modo contiguo in memoria principale. Se la lista dei blocchi di memoria libera contiene i seguenti elementi: A, B, C, D,E,F le cui dimensioni sono rispettivamente 300 KiB, 600 KiB, 350 KiB, 200 KiB,750 KiB e 125 KiB quale blocco verr√† allocato per P assumendo una politica Best-Fit?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "blocco A",
      "blocco B",
      "blocco C",
      "blocco D"
    ],
    "correct": "d",
    "question": "Si supponga che un processo P necessiti di un'area di memoria libera pari a 34 KiB per essere allocato in modo contiguo in memoria principale. Se la lista dei blocchi di memoria libera contiene i seguenti elementi: A, B, C, D le cui dimensioni sono rispettivamente 36 KiB, 90 KiB, 42 KiB e 35 KiB, quale blocco verr√† allocato per P assumendo una politica Best-Fit?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "p=6; offset=5",
      "b.p=7; offset=5",
      "p=5; offset=7",
      "p=5; offset=6"
    ],
    "correct": "d",
    "question": "Si supponga di avere una memoria M di capacit√† pari a 4 KiB, ossia 4,096 bytes. Assumendo che l'indirizzamento avvenga con lunghezza di parola (word size) pari 2 bytes e che M utilizzi una gestione paginata con blocchi di dimensione pari a S = 128 bytes, quanti bit sono necessari per identificare l'indice di pagina (p) e l'offset (interno alla pagina), rispettivamente?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "p=5; offset=12",
      "I dati sono insufficienti per rispondere alla domanda",
      "p=13; offset=0",
      "p=12; offset=5"
    ],
    "correct": "d",
    "question": "Si consideri una memoria M di capacit√† pari a 512 bytes con frame di dimensione pari a 16 bytes. Dato l'indirizzo del byte 197, quale sar√† l'indirizzo di pagina (p) e l'offset (interno alla pagina):",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "p=3; offset=7",
      "I dati sono insufficienti per rispondere alla domanda",
      "p=7; offset=3",
      "p=0; offset=37"
    ],
    "correct": "a",
    "question": "Si consideri una memoria M di capacit√† pari a 100 bytes con frame di dimensione pari a 10 bytes. Dato l‚Äôindirizzo del byte 37, quale sar√† l‚Äôindirizzo di pagina (p) e l‚Äôoffset (interno alla pagina).",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Attendere che vi sia un blocco di dimensione multipla rispetto a quella del processo",
      "Allocare l'intero blocco al processo, sprecando 7 bytes (frammentazione interna)",
      "Attendere che vi sia un blocco di dimensione inferiore adatto a contenere il processo",
      "Allocare la porzione del blocco necessaria al processo e aggiungere alla lista dei blocchi liberi i 7 bytes rimanenti (frammentazione esterna)"
    ],
    "correct": "b",
    "question": "Si consideri un processo di dimensione pari a 2,097 bytes e un blocco di memoria libero di dimensione pari a 2,104 bytes. In questo caso, assumendo il vincolo di allocazione contigua della memoria, la scelta pi√π conveniente √®:",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "2",
      "9",
      "11",
      "I dati sono insufficienti per rispondere al problema"
    ],
    "correct": "b",
    "question": "Si supponga di avere una memoria M di capacit√† pari a 2 KiB, ossia 2,048 bytes. Assumendo che l‚Äôindirizzamento avvenga con lunghezza di parola (word size) pari a 4 bytes, quanti bit sono necessari ad indirizzare le parole contenute in M?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "10",
      "11",
      "12",
      "I dati sono insufficienti per rispondere alla domanda"
    ],
    "correct": "b",
    "question": "Si supponga di avere una memoria M di capacit√† pari a 4 KiB ossia 4,096 bytes. Assumendo che l‚Äôindirizzamento avvenga con lunghezza di parola (word size) pari a 2 bytes, quanti bit sono necessari ad indirizzare le parole contenute in M?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "I dati sono insufficienti per rispondere al problema",
      "13",
      "64",
      "7"
    ],
    "correct": "c",
    "question": "Si supponga di avere una memoria M di capacit√† pari a 8 KiB, ossia 8,192 bytes. Assumendo che l'indirizzamento avvenga con lunghezza di parola (word size) pari al singolo byte e che M utilizzi una gestione paginata con blocchi di dimensione pari a S = 128 bytes, quale dimensione (intesa come numero di entry) ha la corrispondente page table T?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "32",
      "2048",
      "8",
      "5"
    ],
    "correct": "a",
    "question": "Si supponga di avere una memoria M di capacit√† pari a 8 KiB, ossia 8,192 bytes. Assumendo che l‚Äôindirizzamento avvenga con lunghezza di parola (word size) pari a 4 bytes e che M utilizzi una gestione paginata con blocchi di dimensione pari a S = 256 bytes, quale sar√† il numero di entry della corrispondente page table T?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "a",
      "b",
      "c",
      "I dati sono insufficienti per rispondere al problema"
    ],
    "correct": "c",
    "question": "Si supponga di avere una memoria M di capacit√† pari a 16 KiB, ossia 16,384 bytes. Assumendo che l‚Äôindirizzamento avvenga con lunghezza di parola (word size) pari a 4 bytes e che M utilizzi una gestione paginata con blocchi di dimensione pari a S = 64 bytes, quale sar√† il numero di entry della corrispondente page table T?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "32 KiB",
      "64 KiB",
      "2 MiB",
      "Non esiste un limite fisico alla memoria supportata dal sistema"
    ],
    "correct": "b",
    "question": "Si consideri un sistema operativo che utilizza indirizzi logici da 21 bit, indirizzo fisico da 16 bit e memoria paginata in cui ciascuna pagina ha dimensione 2 KiB(2048 bytes). Qual √® la dimensione massima di memoria fisica supportata dal sistema?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Aumentare l'efficienza delle operazioni di I/O",
      "Mantenere allocate in memoria fisica solo alcune pagine dello spazio di indirizzamento logico di un processo",
      "Diminuire il grado di multiprogrammazione del sistema",
      "Eseguire un processo direttamente dai dispositivi di memoria secondaria (e.g., disco)"
    ],
    "correct": "b",
    "question": "La memoria virtuale consente di:",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Il processo di cui fa parte l'istruzione termina",
      "Le istruzioni idempotenti non possono generare page fault",
      "L'istruzione non verr√† pi√π eseguita una volta effettuato il ritorno dalla gestione del page fault",
      "L'istruzione verr√† nuovamente eseguita al ritorno dalla gestione del page fault"
    ],
    "correct": "d",
    "question": "Se un'istruzione idempotente genera un page fault:",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Necessita di un supporto hardware per essere risolto",
      "Non √® risolvibile a meno di un riavvio del sistema",
      "E‚Äô una conseguenza del vincolo di allocazione contigua della memoria",
      "Causa un‚Äôinterruzione hardware"
    ],
    "correct": "c",
    "question": ".Il problema della frammentazione esterna:",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Non √® risolvibile a meno di un riavvio del sistema",
      "Causa un‚Äôinterruzione hardware",
      "Necessita di un supporto hardware per essere risolto",
      "E‚Äô dovuto all‚Äô allocazione/deallocazione di blocchi contigui di memoria"
    ],
    "correct": "d",
    "question": "Il problema della frammentazione esterna",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Fissato per ogni quanto di tempo",
      "Relativamente grande rispetto all‚Äôintero spazio di indirizzamento di un processo",
      "Relativamente piccolo rispetto all‚Äôintero spazio di indirizzamento di un processo",
      "Fissato per l‚Äôintera esecuzione di un processo"
    ],
    "correct": "c",
    "question": "Il working set √®:",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Incrementare una variabile di tipo contatore",
      "Aggiornare il valore del timestamp con quello corrente",
      "Impostare un bit di validit√†",
      "Nessuna delle precedenti risposte √® corretta"
    ],
    "correct": "b",
    "question": "Si consideri un sistema che implementa la politica LRU per la sostituzione dei frame mediante l‚Äôuso di un timestamp. Ad ogni richiesta di accesso ad un determinato frame occorre:",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "4",
      "5",
      "6",
      "7"
    ],
    "correct": "c",
    "question": "Data una memoria composta da 3 frame fisici e un processo composto da 5 pagine virtuali: A, B, C, D, E, si calcoli il numero di page fault che si verificano a fronte delle seguenti richieste da parte del processo: B, C, C, B, A, E, B, A, E, D, B. Si assuma che nessuna pagina del processo sia inizialmente caricata in memoria e che si utilizzi un algoritmo LRU di sostituzione delle pagine.",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "10",
      "7",
      "9",
      "6"
    ],
    "correct": "c",
    "question": "Data una memoria composta da 3 frame fisici e un processo composto da 5 pagine virtuali: A, B, C, D, E, si calcoli il numero di page fault che si verificano a fronte delle seguenti richieste da parte del processo: D, B, A, C, C, E, A, D, B, E, D, A. Si assuma che nessuna pagina del processo sia inizialmente caricata in memoria e che si utilizzi un algoritmo LRU di sostituzione delle pagine.",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "2",
      "4",
      "5",
      "1"
    ],
    "correct": "b",
    "question": "Data una memoria composta da 3 frame fisici e un processo composto da 5 pagine virtuali: A, B, C, D, E, si calcoli il numero di page fault che si verificano a fronte delle seguenti richieste da parte del processo: C,B,C,B,A,E,B,A. Si assuma che nessuna pagina del processo sia inizialmente caricata in memoria e che si utilizzi un algoritmo LRU di sostituzione delle pagine.",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "6",
      "7",
      "4",
      "8"
    ],
    "correct": "b",
    "question": "Data una memoria fisica composta da 3 frame fisici e un processo composto da 5 pagine virtuali: A, B, C, D, E, si calcoli il numero di page fault che si verificano a fronte delle seguenti richieste da parte del processo: A, B, E, C, E, D, D, A, B. Si assuma che nessuna pagina del processo sia inizialmente caricata in memoria e che si utilizzi un algoritmo FIFO di sostituzione delle",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "6",
      "7",
      "5",
      "4"
    ],
    "correct": "b",
    "question": "Data una memoria composta da 3 frame fisici e un processo composto da 5 pagine virtuali: A, B, C, D, E, si calcoli il numero di page fault che si verificano a fronte delle seguenti richieste da parte del processo: D, A, C, B, B, A, C, B, D, E, A. Si assuma che nessuna pagina del processo sia inizialmente caricata in memoria e che si utilizzi un algoritmo FIFO di sostituzione delle pagine.",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "7",
      "8",
      "6",
      "5"
    ],
    "correct": "a",
    "question": "Data una memoria composta da 3 frame fisici e un processo composto da 5 pagine virtuali: A, B, C, D, E si calcoli il numero di page fault che si verificano a fronte delle seguenti richieste da parte del processo: E, B, E, C, D, E, A, B, E. Si assuma che nessuna pagina del processo sia inizialmente caricata in memoria e che si utilizzi un algoritmo FIFO di sostituzione delle pagine.",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "√à ottima sia per l'accesso diretto (random) che per quello sequenziale",
      "Presenta il problema della frammentazione",
      "Necessita il mantenimento dei blocchi liberi all'interno di una opportuna struttura dati",
      "Tutte le risposte precedenti sono corrette"
    ],
    "correct": "d",
    "question": "L'allocazione contigua di un file su disco:",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Un CD/DVD-ROM in sola lettura",
      "Un disco magnetico",
      "Un disco a stato solido",
      "In nessuno dei casi precedenti"
    ],
    "correct": "a",
    "question": "L‚Äôallocazione contigua di un file su un disco √® la scelta preferibile quando il disco √®:",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "√à il tempo necessario al disco per posizionare le proprie testine su uno specifico settore",
      "Include il tempo di trasferimento alla memoria principale",
      "√à il tempo necessario al disco per posizionare le proprie testine su uno specifico cilindro",
      "√à trascurabile rispetto all'intero tempo necessario al trasferimento dei dati"
    ],
    "correct": "c",
    "question": "In un disco magnetico, il seek time:",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "7.5 GB",
      "75 GB",
      "750 MB",
      "I dati sono insufficienti per rispondere al problema4"
    ],
    "correct": "a",
    "question": "Un disco √® composto da 15 cilindri, ciascuno di capacit√† pari a 500 MB. Qual √® la capacit√† totale del disco?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "~30.5 nsec",
      "~30.5 microsec",
      "~3.05 microsec",
      "~305 nsec"
    ],
    "correct": "c",
    "question": "Si supponga che il tempo di accesso alla memoria fisica sia tMA = 50 nsec. e che il tempo per la gestione di un page fault tFAULT  sia pari a 15 msec. Assumendo che la probabilit√† che si verifichi un page fault sia p = 0.0002, qual √® il tempo complessivo atteso di accesso alla memoria?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "~150.025 microsec",
      "~15.025 nsec",
      "~150.025 nsec",
      "~15.025 microsec"
    ],
    "correct": "a",
    "question": "Si supponga che il tempo di accesso alla memoria fisica sia tMA = 25 nsec. e che il tempo per la gestione di un page fault  tFAULT sia pari a 30 msec. Assumendo che la probabilit√† che si verifichi un page fault sia p = 0.005, qual √® il tempo complessivo atteso di accesso alla memoria?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "~0.02%",
      "~0.2%",
      "~0.002%",
      "~0.0002%"
    ],
    "correct": "c",
    "question": "Si supponga che il tempo di accesso alla memoria fisica sia tMA = 50 nsec. e che il tempo per la gestione di un page fault tFAULT sia pari a 25 msec. Assumendo che il tempo medio di accesso alla memoria sia pari a 0.5 microsec, qual √® la probabilit√† p che si verifichi un page fault?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "I dati sono insufficienti per rispondere alla domanda",
      "~0,00024%",
      " ~0,000024%",
      " ~0,0000024%"
    ],
    "correct": "b",
    "question": "Si supponga che il tempo di accesso alla memoria fisica sia tMA  = 60 nsec. e che il tempo per la gestione di un page fault tFAULT  sia pari a 5 msec. Quale dovr√† essere il valore della probabilit√† che si verifichi un fault () se si vuole garantire che il tempo atteso di accesso alla memoria sia al pi√π il 20% pi√π lento di tMA ? (Si ricordi che 1 msec = 10^3 microsec = 10^6 nsec)",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "86",
      "49",
      "123",
      "88"
    ],
    "correct": "d",
    "question": "Si consideri un disco magnetico composto da 128 cilindri/tracce, numerati da 0 a 127 (0 indice del cilindro/traccia pi√π esterno/a rispetto al centro del disco), la cui testina si trova inizialmente sul cilindro 42. Si calcoli il numero di cilindri/tracce attraversate dalla testina del disco, assumendo che la sequenza di richieste: 74, 50, 32, 55, 81 venga gestita da un algoritmo di scheduling SSTF (Shortest Seek Time First) e trascurando il tempo di rotazione.",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "290",
      "240",
      "238",
      "265"
    ],
    "correct": "b",
    "question": "Si consideri un disco magnetico composto da 128 cilindri/tracce, numerati da 0 a 127 (0 indice del cilindro/traccia pi√π esterno/a rispetto al centro del disco), la cui testina si trova inizialmente sul cilindro 87. Si calcoli il numero di cilindri/tracce attraversate dalla testina del disco, assumendo che la sequenza di richieste: 43, 81, 36, 25, 127 venga gestita da un algoritmo di scheduling FCFS (First Come First Served) e trascurando il tempo di rotazione.",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "9.375 MB",
      "7.5 MB",
      "937.5 KB",
      "I dati sono insufficienti per rispondere alla domanda"
    ],
    "correct": "c",
    "question": "Il tempo di trasferimento totale per un'operazione di I/O da disco magnetico √® pari a 30 msec. Sapendo che: il seek time complessivo √® pari a 18 msec, il rotational delay complessivo √® pari a 7 msec e che il transfer rate √® pari a 1.5 Gbit/sec, qual √® la quantit√† totale di dati trasferita? (Si ricordi che 1 B = 1 byte = 8 bit e 1 MB = 10^3 KB = 10^6 B)",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "9375 MB",
      "70 MB",
      "70 KB",
      "I dati sono insufficienti per rispondere alla domanda"
    ],
    "correct": "a",
    "question": "Il tempo di trasferimento totale per un'operazione di I/O da disco magnetico √® pari a 40 msec. Sapendo che: il seek time complessivo √® pari a 18 msec, il rotational delay complessivo √® pari a 7 msec e che il transfer rate √® pari a 5 Gbit/sec, qual √® la quantit√† totale di dati trasferita? (Si ricordi che 1 B = 1 byte = 8 bit e 1 MB = 10^3 KB = 10^6 B)",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "7 msec",
      "2 msec",
      "16 msec",
      "I dati sono insufficiente per rispondere alla domanda"
    ],
    "correct": "a",
    "question": "Il tempo di trasferimento totale per un'operazione di I/O da disco magnetico √® pari a 36 msec. Sapendo che il seek time complessivo √® pari a 13 msec e che sono stati trasferiti 2MB ad una velocit√† pari a 1 Gbit/sec qual √® il rotational delay del disco?(Si ricordi che 1 B = 1 byte = 8 bit)",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "√à condivisa tra tutti i processi",
      "Contiene una entry per ciascun file in uso",
      "Mantiene un contatore per ciascun file in uso",
      "Tutte le risposte precedenti sono corrette"
    ],
    "correct": "d",
    "question": "La tabella globale dei file aperti (global open file table):",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Contiene informazioni di protezione di ciascun file riferita da un processo",
      "Contiene un puntatore alla locazione sul disco di ciascun file riferito da un processo",
      "Contiene un puntatore alla tabella globale dei file aperti per ciascun file riferito da un processo",
      "E‚Äô condivisa tra pi√π processi"
    ],
    "correct": "c",
    "question": "La tabella locale dei file aperti (local open file table):",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Un compilatore",
      "Un sistema di ricerca all'interno di una base di dati",
      "Un sistema di ricerca di contatti telefonici",
      "Nessuna delle risposte precedenti √® corretta"
    ],
    "correct": "a",
    "question": "Un possibile esempio di applicazione che necessita accesso sequenziale ad un file √®:",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "E‚Äô di piccole dimensioni,indipendentemente dal modo in cui viene acceduto",
      "E‚Äô di grandi dimensioni, indipendentemente dal modo in cui viene acceduto",
      "E‚Äô di grandi dimensioni ed √® tipicamente acceduto in modo sequenziale",
      "E‚Äô di grandi dimensioni ed √® tipicamente acceduto in modo casuale(diretto)"
    ],
    "correct": "d",
    "question": "L‚Äôallocazione di un file indicizzata √® preferibile quando il file in questione:",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "E‚Äô di piccolo dimensioni, indipendentemente dal modo in cui viene acceduto",
      "E‚Äô di grandi dimensioni ed √® tipicamente acceduto in modo casuale(diretto)",
      "E‚Äô di grandi dimensioni, indipendentemente dal modo in cui viene acceduto",
      "E‚Äô di grandi dimensioni ed √® tipicamente acceduto in modo sequenziale"
    ],
    "correct": "d",
    "question": "L‚Äôallocazione di un file basata su linked list(liste puntate) √® preferibile quando il file in questione",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Consente al solo proprietario del file di esercitare diritti di lettura e un sistema UNIX-like, un file che ha i seguenti privilegi: 101000000:",
      "Consente al solo proprietario del file di esercitare diritti di lettura ed esecuzione (sul file)",
      "Consente al solo proprietario del file di esercitare diritti di scrittura ed esecuzione (sul file)",
      "Non d√† alcun diritto al proprietario del file"
    ],
    "correct": "b",
    "question": "In un sistema UNIX-like, un file che ha i seguenti privilegi: 101000000 ",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Consente al solo proprietario del file di esercitare diritti di lettura e scrittura (sul file)",
      "Consente al solo proprietario del file di esercitare diritti di lettura ed esecuzione (sul file)",
      "Non d√† alcun diritto al proprietario del file",
      "Consente al solo proprietario del file di esercitare diritti di scrittura ed esecuzione (sul file)"
    ],
    "correct": "d",
    "question": "In un sistema UNIX-like, un file che ha i seguenti privilegi: 011000000 ",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Consente al proprietario del file di esercitare tutti i diritti(sul file) e fornisce agli altri utenti solo diritti di scrittura ed esecuzione",
      "Consente al proprietario del file di esercitare tutti i diritti(sul file) e fornisce agli altri utenti solo diritti di lettura ed scrittura",
      "Consente al proprietario del file di esercitare tutti i diritti(sul file) e fornisce agli altri utenti solo diritti di lettura ed esecuzione",
      "Consente a chiunque di esercitare tutti i diritti (sul file)"
    ],
    "correct": "c",
    "question": "In un sistema UNIX-like, un file che ha i seguenti privilegi: 111101101",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Crea un hard link con il file file_2(sorgente) in cui nome √® file_1(destinazione)",
      "Crea un hard link con il file file_1(sorgente) il cui nome √® file_2(destinazione)",
      "Crea un soft link con il file file_1(sorgente) il cui nome √® file_2(destinazione)",
      "Crea un soft link con il file file_2(sorgente) il cui nome √® file_1(destinazione)"
    ],
    "correct": "b",
    "question": "Il comando UNIX ln file_1 file_2",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Crea un hard link con il file file_2(sorgente) in cui nome √® file_1(destinazione)",
      "Crea un hard link con il file file_1(sorgente) il cui nome √® file_2(destinazione)",
      "Crea un soft link con il file file_1(sorgente) il cui nome √® file_2(destinazione)",
      "Crea un soft link con il file file_2(sorgente) il cui nome √® file_1(destinazione)"
    ],
    "correct": "c",
    "question": "Il comando UNIX ln -s file_1 file2:",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "~20.2 KB",
      "~20.2 MB",
      "~20.7 KB",
      "~20.7 KB"
    ],
    "correct": "d",
    "question": "Si consideri un file system organizzato con file descriptor indicizzati multi-livello (multi-level indexed files), contenente i riferimenti diretti a 10 blocchi a cui si aggiunge un livello di riferimento indiretto a 100 blocchi e un ulteriore doppio livello di riferimento indiretto, sempre da 100 blocchi ciascuno. Assumendo che ciascun blocco abbia dimensione pari a 2 KiB, qual √® la dimensione massima del file supportata?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "595",
      "558",
      "650",
      "638"
    ],
    "correct": "b",
    "question": "Si consideri un disco magnetico composto da 200 cilindri/tracce, numerati da 0 a 199(0 indice del cilindro/traccia pi√π esterno/a rispetto al centro del disco), la cui testina si trova inizialmente sul cilindro 53. Si calcoli il numero di cilindri/tracce attraversate dalla testina del disco, assumendo che la sequenza di richieste: 98,183,37,122,14,85,67 venga gestita da un algoritmo di scheduling FCFS (First Come First Served) e trascurando il tempo di rotazione.",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "650",
      "522",
      "638",
      "595"
    ],
    "correct": "b",
    "question": "Si consideri un disco magnetico composto da 200 cilindri/tracce, numerati da 0 a 199(0 indice del cilindro/traccia pi√π esterno/a rispetto al centro del disco), la cui testina si trova inizialmente sul cilindro 53. Si calcoli il numero di cilindri/tracce attraversate dalla testina del disco, assumendo che la sequenza di richieste: 98,183,37,122,14,65,67 venga gestita da un algoritmo di scheduling FCFS (First Come First Served) e trascurando il tempo di rotazione.",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "76",
      "87",
      "46",
      "93"
    ],
    "correct": "d",
    "question": "Si consideri un disco magnetico composto da 100 cilindri/tracce, numerati da 0 a 99 (0 indice del cilindro/traccia pi√π esterno/a rispetto al centro del disco), la cui testina si trova inizialmente sul cilindro 11. Si calcoli il numero di cilindri/tracce attraversate dalla testina del disco, assumendo che la sequenza di richieste: 24, 16, 77, 49, 82 venga gestita da un algoritmo di scheduling SCAN (non-ottimizzato), che la testina si stia muovendo verso l'esterno (i.e., verso i cilindri con numeri pi√π bassi) e trascurando il tempo di rotazione.",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "5",
      "20",
      "15",
      "I dati sono insufficiente per rispondere alla domanda"
    ],
    "correct": "a",
    "question": "Data la porzione di codice in figura, indicare quale sar√† il valore della variabile value che verr√† stampato alla line 18:",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "A",
      "B",
      "C",
      "D"
    ],
    "correct": "b",
    "question": "Data la porzione di codice in figura, indicare il corrispondente albero dei processi generati:",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "A",
      "B",
      "C",
      "D"
    ],
    "correct": "b",
    "question": "Data la porzione di codice in figura, indicare il corrispondente albero dei, indicare il corrispondente albero dei processi generati:",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "FCFS",
      "RR",
      "SJF",
      "Tutte e tre le politiche garantiscono al processo C lo stesso tempo di attesa"
    ],
    "correct": "a",
    "question": "Si considerino i 5 processo della figura seguente e 3 politiche di scheduling: FCFS, SJF (non-preemptive) e RR con time slice pari a 2 unit√† di tempo. Qual √® la politica che garantisce il minor tempo di attesa (in coda pronti) al processo C?",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "6.5",
      "6.75",
      "7.15",
      "5,85"
    ],
    "correct": "b",
    "question": "Calcolare il tempo medio di attesa (average waiting time) dei seguenti processi, assumendo una politica di scheduling round robin con time slice = 3, nessuna attivit√† di I/O e context switch trascurabile:",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "4.85",
      "4.25",
      "4.5",
      "4.75"
    ],
    "correct": "b",
    "question": "Calcolare il tempo medio di attesa (average waiting time) dei seguenti processi, assumendo una politica di scheduling Round Robin con time slice q= 4. Nel calcolo, si consideri il tempo necessario ad eseguire il context switch trascurabile:",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "6",
      "5.75",
      "4.5",
      "5"
    ],
    "correct": "b",
    "question": "Calcolare il tempo medio di attesa (average waiting time) dei seguenti processi, assumendo una politica di scheduling Shortest Job First preemptive (SJF). Nel calcolo, si consideri trascurabile il tempo necessario ad eseguire il context switch:",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "4.5",
      "5.5",
      "7.5",
      "6.5"
    ],
    "correct": "a",
    "question": "Calcolare il tempo medio di attesa (average waiting time) dei seguenti processi, assumendo una politica di scheduling First Come First Served (FCFS) e che il processo A esegua all'istante t=2 una chiamata di I/O che si completer√† dopo 4 unit√† di tempo, ossia all'istante t=6. Nel calcolo, si consideri trascurabile il tempo necessario ad eseguire il context switch:",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "4.5",
      "5.25",
      "4",
      "4.25"
    ],
    "correct": "c",
    "question": "Calcolare il tempo medio di attesa (average waiting time) dei seguenti processi, assumendo una politica di scheduling First Come First Served (FCFS) e che il processo B esegua all'istante t=6 una chiamata di I/O che si completer√† dopo 3 unit√† di tempo, ossia all'istante t=9. Nel calcolo, si consideri trascurabile il tempo necessario ad eseguire il context switch:",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "72",
      "73",
      "74",
      "I dati sono insufficienti per rispondere alla domanda"
    ],
    "correct": "b",
    "question": "",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "23",
      "24",
      "25",
      "I dati sono insufficienti per rispondere alla domanda"
    ],
    "correct": "c",
    "question": "",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "18",
      "19",
      "20",
      "I dati sono insufficienti per rispondere alla domanda"
    ],
    "correct": "a",
    "question": "",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Dipende dalle scelte dello scheduler del sistema operativo",
      "Presenta deadlock",
      "Non presenta deadlock",
      "√à impossibile rispondere"
    ],
    "correct": "c",
    "question": "Il seguente Resource Allocation Graph (RAG) mostra un sistema il cui stato:",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Dipende dalle scelte dello scheduler del sistema operativo",
      "Presente deadlock",
      "Non presenta deadlock",
      "E‚Äô impossibile rispondere"
    ],
    "correct": "c",
    "question": "Il seguente Resource Allocation Graph (RAG) mostra un sistema il cui stato:",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Sicuramente presenta deadlock",
      "Potrebbe presentare deadlock",
      "Sicuramente non presenta deadlock",
      "E‚Äô impossibile rispondere"
    ],
    "correct": "c",
    "question": "Il seguente Resource Allocation Graph (RAG) mostra un sistema il cui stato:",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "Sicuramente presenta deadlock",
      "Potrebbe presentare deadlock",
      "Sicuramente non presenta deadlock",
      "E‚Äô impossibile rispondere"
    ],
    "correct": "a",
    "question": "Il seguente Resource Allocation Graph(RAG) mostra un sistema che:",
    "answers_have_code": 0,
    "code": ""
  },
  {
    "answers": [
      "76",
      "87",
      "46",
      "93"
    ],
    "correct": "c",
    "question": "Si consideri un disco magnetico composto da 100 cilindri/tracce, numerati da 0 a 99 (0 indice del cilindro/traccia pi√π esterno/a rispetto al centro del disco), la cui testina si trova inizialmente sul cilindro 11. Si calcoli il numero di cilindri/tracce attraversate dalla testina del disco, assumendo che la sequenza di richieste: 24, 16, 77, 49, 82 venga gestita da un algoritmo di scheduling SCAN (non-ottimizzato), che la testina si stia muovendo verso l'esterno (i.e., verso i cilindri con numeri pi√π bassi) e trascurando il tempo di rotazione.",
    "answers_have_code": 0,
    "code": ""
  }
]